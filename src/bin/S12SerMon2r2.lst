
Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
    1    1                      ;.pagewidth  120t
    2    2                      ;*********************************************************************
    3    3                      ;* Title:  S12SerMonxrx.asm        Copyright (c) Motorola 2003
    4    4                      ;*********************************************************************
    5    5                      ;* Author: Jim Sibigtroth - Motorola TSPG - 8/16 Bit Division
    6    6                      ;* Author: Jim Williams - Motorola TSPG - 8/16 Bit Division
    7    7                      ;*
    8    8                      ;* Description: Bootloader/Monitor program for HCS9S12
    9    9                      ;* bootloader will reside in 2K of block protected memory at the
   10   10                      ;* end of the memory map of an HCS9S12 MCU ($F7FF-$FFFF).
   11   11                      ;*
   12   12                      ;* Since this code is located in the vector space, all interrupt
   13   13                      ;* vectors will be mirrored to the pseudo vector table in user
   14   14                      ;* erasable and reprogrammable flash memory just before the start
   15   15                      ;* of the protected bootloader code.
   16   16                      ;*
   17   17                      ;* If a non-FFFF user reset vector is programmed into the
   18   18                      ;* pseudo-reset vector, the bootloader will jump to that routine
   19   19                      ;* so the user can control all options including write-once bits.
   20   20                      ;*
   21   21                      ;* This monitor program implements 23 primitive monitor commands that
   22   22                      ;* are very similar to BDM commands. Third-party tool vendors can
   23   23                      ;* adapt their existing BDM-based tools to work through a serial I/O
   24   24                      ;* cable rather than a BDM pod, simply by providing a set of alternate
   25   25                      ;* interface routines. Although this monitor approach has some
   26   26                      ;* limitations compared to the BDM approach, it provides a free or
   27   27                      ;* very low cost alternative for the most cost-sensitive users.
   28   28                      ;*
   29   29                      ;* This monitor uses SCI0 as the primary interface to the target MCU
   30   30                      ;* system and SCI0 Rx interrupts are used to break out of a running
   31   31                      ;* user program. This implies that some monitor functions will not be
   32   32                      ;* available if the I bit in the CCR is not clear during execution of
   33   33                      ;* the user's program. During debug of user initialization programs
   34   34                      ;* and interrupt service routines when the I bit is not clear, trace
   35   35                      ;* and breakpoint functions still work as expected because these
   36   36                      ;* functions use on-chip breakpoint logic. 
   37   37                      ;*
   38   38                      ;*
   39   39                      ;*
   40   40                      ;* Revision History: not yet released
   41   41                      ;* Rev #     Date      Who     Comments
   42   42                      ;* -----  -----------  ------  ---------------------------------------
   43   43                      ;*  2.00   04-SEP-03   JPW     First Release.
   44   44                      ;*  2.01   03-DEC-03   JPW     MC9S12NE64 support added, fixed user jump table,
   45   45                      ;*                             fixed PLL/Timer Ch.7 corruption 
   46   46                      ;*                             Added Flash/EEPROM support > 12.8MHz OSC
   47   47                      ;*  2.02   23-JUL-04   JPW     Fixed PPAGE coruption in erase and programming
   48   48                      ;*                             routines - Allow $8000 page to be programmed
   49   49                      ;*                             if PPAGE = $00. Supports GNU compiler.
   50   50                      ;
   51   51                      ;
   52   52          0000 0723   softwareID1:  equ   $0723     ;Software revision (date)
   53   53          0000 2004   softwareID2:  equ   $2004     ;Software revision (year)
   54   54          0000 0202   softwareID3:  equ   $0202     ;Software revision (ver)
   55   55                      
   56   56                      ;*
   57   57                      ;*
   58   58                      ;*********************************************************************
   59   59                      ;*********************************************************************
   60   60                      ;* Motorola reserves the right to make changes without further notice
   61   61                      ;* to any product herein to improve reliability, function, or design.
   62   62                      ;* Motorola does not assume any liability arising out of the
   63   63                      ;* application or use of any product, circuit, or software described
   64   64                      ;* herein; neither does it convey any license under its patent rights

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
   65   65                      ;* nor the rights of others.  Motorola products are not designed,
   66   66                      ;* intended, or authorized for use as components in systems intended
   67   67                      ;* for surgical implant into the body, or other applications intended
   68   68                      ;* to support life, or for any other application in which the failure
   69   69                      ;* of the Motorola product could create a situation where personal
   70   70                      ;* injury or death may occur.  Should Buyer purchase or use Motorola
   71   71                      ;* products for any such intended or unauthorized application, Buyer
   72   72                      ;* shall indemnify and hold Motorola and its officers, employees,
   73   73                      ;* subsidiaries, affiliates, and distributors harmless against all
   74   74                      ;* claims, costs, damages, and expenses, and reasonable attorney fees
   75   75                      ;* arising out of, directly or indirectly, any claim of personal
   76   76                      ;* injury or death associated with such unintended or unauthorized
   77   77                      ;* use, even if such claim alleges that Motorola was negligent
   78   78                      ;* regarding the design or manufacture of the part.
   79   79                      ;*
   80   80                      ;* Motorola is a registered trademark of Motorola, Inc.
   81   81                      ;*********************************************************************
   82   82                      
   83   83                                  XDEF Startup         ;make symbol visible to the MW linker
   84   84                      ;*********************************************************************
   85   85                      ;* Include standard definitions that are common to all derivatives
   86   86                      ;*********************************************************************
   87   87                      ;             base    10           ;ensure default number base to decimal
  651   92                      ;*********************************************************************
  652   93                      ;* general equates for bootloader/monitor program valid for all
  653   94                      ;* derivatives
  654   95                      ;*********************************************************************
  655   96          0000 F800   BootStart:   equ    $F800         ;start of protected boot block
  656   97          0000 3FFF   RamLast:     equ    $3fff         ;last RAM location (all devices)
  657   98          0000 8000   Window:      equ    $8000         ;PPAGE Window start
  658   99          0000 4000   RomStart:    equ    $4000         ;start of flash
  659  100          0000 0080   VecTabSize:  equ    $80           ;size of vector table
  660  101          0000 FF80   VectorTable: equ    $10000-VecTabSize ;start of vector table
  661  102          0000 F780   PVecTable:   equ    BootStart-VecTabSize ;start of pseudo vector table
  662  103          0000 FF00   FProtStart:  equ    $FF00         ;start of FLASH protection/security
  663  104          0000 00C7   FProtBlksz:  equ    $C7           ;protect code for boot block ($C7 2K)
  664  105                      ;FProtBlksz:  equ    $FF           ;protect code for boot block (none)
  665  106          0000 00BE   FSecure:     equ    $BE           ;Disable Security and backdoor access
  666  107                      ;FSecure:     equ    $00           ;Enable Security and backdoor access
  667  108                      
  668  109          0000 5DC0   BusFreq:     equ    ((OscFreq/(initREFDV+1))*(initSYNR+1))
  669  110          0000 000D   baud115200:  equ    (BusFreq/16)*10/1152  ;sets baud rate to 115,200
  670  111          0000 05DC   longBreak:   equ    1500          ;delay time for >30-bit break
  671  112                      ; make TxD low at least 300us (30 bits @ 115200 baud)
  672  113                      ; 5~ * 42ns/~ * 1500 = 315us (not exact, just >30 bit times)
  673  114          0000 000D   asciiCR:     equ    $0D           ;ascii carriage return
  674  115                      
  675  116          0000 00CA   flagReg:     equ    SCI0CR1       ;SCI control1 reg of SCI0
  676  117          0000 0008   RunFlag:     equ    WAKE          ;SCI Wake bit used as run/mon flag
  677  118          0000 0020   ArmFlag:     equ    RSRC          ;SCI RSRC bit used for ARM storage
  678  119          0000 0004   TraceFlag:   equ    ILT           ;SCI Idle bit used as trace flag
  679  120                      ; 1=SWI caused by return from Trace1; 0=SWI from breakpoint or DBG
  680  121                      
  681  122          0000 000C   initSCI0CR2: equ    $0C           ;SCI0 Control Register 2
  682  123          0000 0080   traceOne:    equ    $80           ;BKPCT0 pattern for trace1 cmd
  683  124                      ;
  684  125                      ;CPU HCS12 CCR immediately after reset is:
  685  126          0000 00D0   initUCcr:    equ    %11010000     ;initial value for user's CCR
  686  127                      ;                    SX-I----     ;I interrupts masked
  687  128                      								  ;(SXHINZVC=11x1xxxx).
  688  129                      
  689  130          0000 00E0   ErrNone:     equ    $E0           ;code for no errors
  690  131          0000 00E1   ErrCmnd:     equ    $E1           ;command not recognized
  691  132          0000 00E2   ErrRun:      equ    $E2           ;command not allowed in run mode

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  692  133          0000 00E3   ErrSP:       equ    $E3           ;SP was out of range
  693  134          0000 00E4   ErrWriteSP:  equ    $E4           ;attempted to write bad SP value
  694  135          0000 00E5   ErrByteNVM:  equ    $E5           ;write_byte attempt NVM
  695  136          0000 00E6   ErrFlash:    equ    $E6           ;FACCERR or FPVIOL error
  696  137          0000 00E7   ErrFlErase:  equ    $E7           ;Error code not implemented
  697  138          0000 00E8   ErrGoVec:    equ    $E8           ;Error code not implemented
  698  139          0000 00E9   ErrEeErase   equ    $E9			      ;EACCERR or EPVIOL error
  699  140                      
  700  141          0000 0002   StatHalt:    equ    $02           ;stopped by Halt command
  701  142          0000 0004   StatTrace:   equ    $04           ;returned from a Trace1 command
  702  143          0000 0006   StatBreak:   equ    $06           ;Breakpoint or DBG (SWI) request
  703  144          0000 0008   StatCold:    equ    $08           ;just did a cold reset
  704  145          0000 000C   StatWarm:    equ    $0C           ;warm start because int with bad SP
  705  146                      
  706  147                      ;*********************************************************************
  707  148                      ;* User CPU registers stack frame...
  708  149                      ;*   +0  UCcr   <- Monitor's SP
  709  150                      ;*   +1  UDreg   (B:A)
  710  151                      ;*   +3  UXreg
  711  152                      ;*   +5  UYreg
  712  153                      ;*   +7  UPc
  713  154                      ;*   +9  ---     <- User's SP
  714  155                      ; Offsets from actual SP to user CPU regs while in monitor
  715  156                      ;*********************************************************************
  716  157                      
  717  158          0000 0000   UCcr:        equ    0             ;user's CCR register
  718  159          0000 0001   UDreg:       equ    1             ;user's D register (B:A)
  719  160          0000 0003   UXreg:       equ    3             ;user's X register
  720  161          0000 0005   UYreg:       equ    5             ;user's Y register
  721  162          0000 0007   UPc:         equ    7             ;user's PC
  722  163          0000 0009   SPOffset:    equ    9             ;offset of stack pointer while in monitor
  723  164                      
  724  165          0000 0023   MaxMonStack  equ   35             ;maximum number of bytes used by Monitor
  725  166          0000 301A   LowSPLimit   equ   RamStart+MaxMonStack-SPOffset
  726  167          0000 3FF7   HighSPLimit  equ   RamLast-SPOffset+1
  727  168                      
  728  169                      ; named locations on stack if SWI with bad SP value
  729  170                      ;*********************************************************************
  730  171                      ;* Start of code and/or constant data
  731  172                      ;*********************************************************************
  732  173                                   org    BootStart      ;beginning of protected flash
  733  174                      ;*********************************************************************
  734  175                      ;* Main startup program - real reset vector points to here
  735  176                      ;*********************************************************************
  736  177                      ;*********************************************************************
  737  178                      ;  THIS LOCKS RAM / REGS / AND EEPROM BY USING ONLY WRITE USER CODE 
  738  179                      ;  WILL NOT EFFECT THESE SETTINGS...This is for derivative compatibility
  739  180                      ;  Please refer to EB388
  740  181                      ;*********************************************************************
  741  182                      ColdStart:  
  742  183                      Startup:
  743  184                      main:
  744  185  a00F800 180B 0000                movb  #$00,INITRG    ;set registers at $0000 
             00F804 11         
  745  186  a00F805 180B 3900                movb  #$39,INITRM    ;set ram to end at $3fff 
             00F809 10         
  746  187  a00F80A 4F1C 3005                brclr  MEMSIZ0,eep_sw1+eep_sw0,ColdStart1  ;Check if device has EEprom
  747  188  a00F80E 180B 0900                movb  #$09,INITEE    ;set eeprom to end at $0fff 
             00F812 12         
  748  189                                   
  749  190  a00F813 87          ColdStart1:     clra                 ;A=0=cold start; see tsta @ ChkCold
  750  191                      
  751  192                      ;**********************************************************************
  752  193                      ; Decide whether to go to user reset or bootloader/monitor

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  753  194                      ;**********************************************************************
  754  195                      ;  (a) default to monitor if high byte user pseudo-vector is erased ($FF)
  755  196                      ;**********************************************************************
  756  197  a00F814 F6F7 FE                  ldab   vector00-($10000-BootStart) ;check for user reset Vector
  757  198  a00F817 51                       comb                 ;if erased COMB result will be 0
  758  199  a00F818 2728                     beq    Monitor       ;default to monitor if no vector
  759  200                      
  760  201                      ;**********************************************************************
  761  202                      ; Test the state of some  pins to force entering the monitor
  762  203                      ;   Depending on the hardware configuration enable/disable/modify the
  763  204                      ;   sections below
  764  205                      ;**********************************************************************
  765  206  a00F81A 1C02 5310                bset   SwPullup,mSwPullup ;enable pullup on force monitor sw
  766  207  a00F81E 1C02 4D01                bset   PPSS,PPSS0    ;enable pullup on RxD0 pin
  767  208  a00F822 1C02 4C01                bset   PERS,PERS0    ;on RxD0 pin
  768  209  a00F826 C7                       clrb
  769  210  a00F827 0431 FD                  dbne   b,*           ;delay to allow sw pin to pull up
  770  211                      ;**********************************************************************
  771  212                      ;  (b) force monitor if SwPort bit SWITCH = 0 
  772  213                      ;  Note: this port is configured after reset as input with pull-up
  773  214                      ;  With no connection to this pin the monitor jumps to run mode
  774  215                      ;**********************************************************************
  775  216  a00F82A F602 50                  ldab   SwPort        ;get port value
  776  217  a00F82D C510                     bitb   #Switch       ;test the sw bit
  777  218  a00F82F 2711                     beq    Monitor
  778  219                      
  779  220                      ;**********************************************************************
  780  221                      ;  (c) force monitor if RxD low (from host)  PORTS bit 0
  781  222                      ;      This is true if the host holds RxD on break level
  782  223                      ;  Note: this port is configured after reset as input with pull-up
  783  224                      ;**********************************************************************
  784  225  a00F831 1F02 4801                brclr  PTS,PTS0,Monitor ;to monitor if RxD low
             00F835 0C         
  785  226  a00F836 1D02 4D01                bclr   PPSS,PPSS0    ;restore reset state on RxD0 pin
  786  227  a00F83A 1D02 4C01                bclr   PERS,PERS0    ;restore reset state on RxD1 pin
  787  228                      
  788  229                      ;**********************************************************************
  789  230                      ;  finally jump to the user application (by pseudo vector)
  790  231                      ;**********************************************************************
  791  232  a00F83E 05FB xxxx                jmp    [vector00-($10000-BootStart),pcr] ;go where
  792  233                                                              ;user reset vector points
  793  234                      ;*********************************************************************
  794  235                      ;  Formal start of Monitor code
  795  236                      ;*********************************************************************
  796  237                      Monitor:
  797  238                      ; Initialize clock generator and PLL
  798  239                      ;
  799  240                      
  800  241                      ; Below "help" on TA C32 card with incorrect DTR connection.
  801  242                      
  802  243                      ;             bclr		 PORTB,PTB4
  803  244                      ;             bset		 DDRB,DDRB4
  804  245                          
  805  246  a00F842 1D02 5310                bclr    SwPullup,mSwPullup ;restore reset state
  806  247  a00F846 4D39 80                  bclr    CLKSEL,PLLSEL      ;disengage PLL to system
  807  248  a00F849 4C3A 40                  bset    PLLCTL,PLLON       ;turn on PLL
  808  249  a00F84C 180B 0200                movb    #initSYNR,SYNR     ;set PLL multiplier 
             00F850 34         
  809  250  a00F851 180B 0100                movb    #initREFDV,REFDV   ;set PLL divider
             00F855 35         
  810  251  a00F856 A7                       nop
  811  252  a00F857 A7                       nop
  812  253  a00F858 4F37 08FC                brclr   CRGFLG,LOCK,*+0    ;while (!(crg.crgflg.bit.lock==1))
  813  254  a00F85C 4C39 80                  bset    CLKSEL,PLLSEL      ;engage PLL to system

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  814  255                      ;
  815  256                      ; set flash/EEPROM clock to 200 kHz
  816  257                      ;
  817  258          0000 0001     IF OscFreq >= 12800
  818  259  a00F85F 180B 4901                movb  #((OscFreq/200/8)-1)+$40,FCLKDIV ;Flash CLK = 200 kHz
             00F863 00         
  819  260  a00F864 180B 4901                movb  #((OscFreq/200/8)-1)+$40,ECLKDIV    ;Eeprom CLK = 200 kHz
             00F868 10         
  820  261                        ELSE	
  823  264                        ENDIF
  824  265                      ;
  825  266                      ; Set stack pointer to last (highest) RAM location
  826  267                      ;
  827  268  a00F869 CF40 00     stackInit:   lds    #RamLast+1    ;point one past RAM
  828  269                      
  829  270                      ; Setup initial user CPU register values (user register stack frame)
  830  271                      ;   A holds the initial state value
  831  272  a00F86C FEF7 FE     initUregs:   ldx   BootStart-2    ;load user reset vector
  832  273  a00F86F 34                       pshx                 ;$00 to user UPc      $3FFe
  833  274  a00F870 CE00 00                  ldx   #$0000
  834  275  a00F873 34                       pshx                 ;$00 to user UYreg    $3ffc
  835  276  a00F874 34                       pshx                 ;$00 to user UXreg    $3ffa
  836  277  a00F875 34                       pshx                 ;$00 to user UDreg    $3ff8
  837  278  a00F876 C6D0                     ldab  #initUCcr      ;initial value for user CCR
  838  279  a00F878 37                       pshb                 ;to UCcr              $3ff7
  839  280                      
  840  281                      ;
  841  282                      ; set baud rate to 115.2 kbaud and turn on Rx and Tx
  842  283                      ;
  843  284  a00F879 180B 0D00                movb  #baud115200,SCI0BDL  ;..BDH=0 so baud = 115.2 K
             00F87D C9         
  844  285  a00F87E 180B 0C00                movb  #initSCI0CR2,SCI0CR2 ;Rx and Tx on
             00F882 CB         
  845  286                      ;
  846  287                      ; if warm start, skip break. A is a flag to indicate cold vs warm start.
  847  288                      ; Avoid using A above here *****
  848  289                      ;
  849  290  a00F883 97          ChkCold:     tsta                ;0=cold start, non-zero=warm start
  850  291  a00F884 2709                     beq    coldBrk      ;if cold send break
  851  292                      ;
  852  293                      ; Send a warm start prompt and wait for new commands
  853  294                      ;
  854  295  a00F886 86E3                     ldaa  #ErrSP        ;error code for bad SP
  855  296  a00F888 16FC 8C                  jsr    PutChar      ;send error code (1st prompt char)
  856  297  a00F88B 860C                     ldaa  #StatWarm     ;status code for warm start
  857  298  a00F88D 202F                     bra    EndPrompt    ;finish warm start prompt
  858  299                      ;
  859  300                      ; Cold start so Generate long break to host
  860  301                      ;
  861  302  a00F88F 4FCC 80FC   coldBrk:     brclr  SCI0SR1,TDRE,* ;wait for Tx (preamble) empty
  862  303  a00F893 4CCB 01                  bset   SCI0CR2,SBK   ;start sending break after preamble
  863  304  a00F896 CE05 DC                  ldx   #longBreak     ;at least 30 bit times for Windows
  864  305  a00F899 8E00 00     BrkLoop:     cpx   #0             ;[2]done?
  865  306  a00F89C 0435 FA                  dbne   x,BrkLoop     ;[3]
  866  307  a00F89F 4DCB 01                  bclr   SCI0CR2,SBK   ;stop sending breaks
  867  308                      
  868  309  a00F8A2 16FC 83     waitforCR:   jsr    GetChar       ;should be asciiCR or $00 with FE=1
  869  310  a00F8A5 810D                     cmpa  #asciiCR       ;.eq. if 115.2K baud OK
  870  311  a00F8A7 26F9                     bne    waitforCR
  871  312                      
  872  313                      ;*********************************************************************
  873  314                      ;* end of reset initialization, begin body of program
  874  315                      ;*********************************************************************
  875  316                      ;

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  876  317                      ; Send a cold start prompt and wait for new commands
  877  318                      ;
  878  319  a00F8A9 86E0                     ldaa  #ErrNone       ;code for no errors ($E0)
  879  320  a00F8AB 16FC 8C                  jsr    PutChar       ;send error code (1st prompt char)
  880  321  a00F8AE 8608                     ldaa  #StatCold      ;status code for cold start ($08)
  881  322  a00F8B0 200C                     bra    EndPrompt     ;finish warm start prompt
  882  323                      ;
  883  324                      ; normal entry point after a good command
  884  325                      ; Prompt is an alt entry point if an error occurred during a command
  885  326                      ; endPrompt is an alternate entry for Trace1, Break (SWI), Halt,
  886  327                      ; or warm/cold resets so an alternate status value can be sent
  887  328                      ; with the prompt
  888  329                      ;
  889  330                      
  890  331  a00F8B2 86E0        CommandOK:   ldaa  #ErrNone       ;code for no errors ($E0)
  891  332  a00F8B4 16FC 8C     Prompt:      jsr    PutChar       ;send error code
  892  333  a00F8B7 96CA                     ldaa   flagReg       ;0 means monitor active mode
  893  334  a00F8B9 8408                     anda  #RunFlag       ;mask for run/monitor flag (SCI WAKE)
  894  335  a00F8BB 44                       lsra                 ;shift flag to LSB
  895  336  a00F8BC 44                       lsra                 ; for output as status
  896  337  a00F8BD 44                       lsra                 ;$00=monitor active, $01=run
  897  338  a00F8BE 16FC 8C     EndPrompt:   jsr    PutChar       ;send status code
  898  339  a00F8C1 863E                     ldaa  #'>'
  899  340  a00F8C3 16FC 8C                  jsr    PutChar       ;send 3rd character of prompt seq
  900  341                                   
  901  342                      ;test flagReg for run / DBG arm status.
  902  343  a00F8C6 4FCA 080A                brclr  flagReg,RunFlag,Prompt1  ;no exit if run flag clr
  903  344  a00F8CA 4FCA 2003                brclr  flagReg,ArmFlag,PromptRun  ;If DBG was not armed just run
  904  345  a00F8CE 4C20 40                  bset	DBGC1,ARM	  ;re-arm DBG module
  905  346  a00F8D1 06FC 68     PromptRun:   jmp    GoCmd         ;run mode so return to user program
  906  347                      
  907  348                      
  908  349  a00F8D4 16FC 83     Prompt1:     jsr    GetChar       ;get command code character
  909  350  a00F8D7 CEF8 ED                  ldx   #commandTbl    ;point at first command entry
  910  351  a00F8DA A100        CmdLoop:     cmpa    ,x           ;does command match table entry?
  911  352  a00F8DC 270B                     beq    DoCmd          ;branch if command found
  912  353  a00F8DE 1A03                     leax   3,x
  913  354  a00F8E0 8EF9 32                  cpx   #tableEnd      ;see if past end of table
  914  355  a00F8E3 26F5                     bne    CmdLoop       ;if not, try next entry
  915  356  a00F8E5 86E1                     ldaa  #ErrCmnd       ;code for unrecognized command
  916  357  a00F8E7 20CB                     bra    Prompt        ;back to prompt; command error
  917  358                                   
  918  359  a00F8E9 EE01        DoCmd:       ldx    1,x           ;get pointer to command routine
  919  360  a00F8EB 0500                     jmp     ,x           ;go process command
  920  361                      ;
  921  362                      ; all commands except GO, Trace_1, and Reset to user code - jump to
  922  363                      ; Prompt after done. Trace_1 returns indirectly via a SWI.
  923  364                      ;
  924  365                      ;*********************************************************************
  925  366                      ;* Command table for bootloader/monitor commands
  926  367                      ;*  each entry consists of an 8-bit command code + the address of the
  927  368                      ;*  routine to be executed for that command.
  928  369                      ;*********************************************************************
  929  370  a00F8ED A1          commandTbl:  fcb   $A1
  930  371  a00F8EE FAFB                     fdb  RdByteCmd     ;read byte
  931  372  a00F8F0 A2                       fcb   $A2
  932  373  a00F8F1 FB86                     fdb  WtByteCmd     ;write byte
  933  374  a00F8F3 A3                       fcb   $A3
  934  375  a00F8F4 FB06                     fdb  RdWordCmd     ;read word of data 
  935  376  a00F8F6 A4                       fcb   $A4
  936  377  a00F8F7 FBA0                     fdb  WtWordCmd     ;write word of data 
  937  378  a00F8F9 A5                       fcb   $A5
  938  379  a00F8FA FB71                     fdb  RdNextCmd     ;read next word
  939  380  a00F8FC A6                       fcb   $A6

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  940  381  a00F8FD FBA8                     fdb  WtNextCmd     ;write next word
  941  382  a00F8FF A7                       fcb   $A7
  942  383  a00F900 FB16                     fdb  ReadCmd       ;read n bytes of data
  943  384  a00F902 A8                       fcb   $A8
  944  385  a00F903 FB2D                     fdb  WriteCmd      ;write n bytes of data
  945  386  a00F905 A9                       fcb   $A9
  946  387  a00F906 FBC6                     fdb  RdRegsCmd     ;read CPU registers
  947  388  a00F908 AA                       fcb   $AA
  948  389  a00F909 FC1D                     fdb  WriteSpCmd    ;write SP
  949  390  a00F90B AB                       fcb   $AB
  950  391  a00F90C FC15                     fdb  WritePcCmd    ;write PC
  951  392  a00F90E AC                       fcb   $AC
  952  393  a00F90F FC0D                     fdb  WriteIYCmd    ;write IY
  953  394  a00F911 AD                       fcb   $AD
  954  395  a00F912 FC05                     fdb  WriteIXCmd    ;write IX
  955  396  a00F914 AE                       fcb   $AE
  956  397  a00F915 FBF7                     fdb  WriteDCmd     ;write D
  957  398  a00F917 AF                       fcb   $AF
  958  399  a00F918 FBEF                     fdb  WriteCcrCmd   ;write CCR
  959  400  a00F91A B1                       fcb   $B1
  960  401  a00F91B FC68                     fdb  GoCmd         ;go
  961  402  a00F91D B2                       fcb   $B2
  962  403  a00F91E FC40                     fdb  Trace1Cmd     ;trace 1
  963  404  a00F920 B3                       fcb   $B3
  964  405  a00F921 F946                     fdb  HaltCmd       ;halt
  965  406  a00F923 B4                       fcb   $B4
  966  407  a00F924 F982                     fdb  ResetCmd      ;reset - to user vector or monitor
  967  408                      ;            $B5 - Command not implemented
  968  409  a00F926 B6                       fcb   $B6          ;code - erase flash command
  969  410  a00F927 F9F3                     fdb  EraseAllCmd   ;erase all flash and eeprom command routine
  970  411  a00F929 B7                       fcb   $B7          ;return device ID
  971  412  a00F92A F932                     fdb  DeviceCmd
  972  413  a00F92C B8                       fcb   $B8          ;erase current flash bank selected in PPAGE
  973  414  a00F92D FAAC                     fdb  ErsPage
  974  415  a00F92F B9                       fcb   $B9			;Bulk erase eeprom if available
  975  416  a00F930 F9C1                     fdb  EraseEECmd	;
  976  417          0000 F932   tableEnd:    equ    *           ;end of command table marker
  977  418                      
  978  419                      ;*********************************************************************
  979  420                      ;* Device ID Command -  Ouputs hex word from device ID register
  980  421                      ;*********************************************************************
  981  422  a00F932 86DC        DeviceCmd:   ldaa   #$DC         ;get part HCS12 descripter
  982  423  a00F934 16FC 8C                  jsr    PutChar      ;out to term
  983  424  a00F937 961A                     ldaa   PARTIDH      ;get part ID high byte
  984  425  a00F939 16FC 8C                  jsr    PutChar      ;out to term
  985  426  a00F93C 961B                     ldaa   PARTIDL      ;get part ID low byte
  986  427  a00F93E 16FC 8C                  jsr    PutChar      ;out to term
  987  428  a00F941 86E0                     ldaa   #ErrNone     ;error code for no errors
  988  429  a00F943 06F8 B4                  jmp    Prompt       ;ready for next command
  989  430                      
  990  431                      
  991  432                      ;*********************************************************************
  992  433                      ;* Halt Command - halts user application and enters Monitor
  993  434                      ;*   This command is normally sent by the debugger while the user
  994  435                      ;*   application is running. It changes the state variable in order
  995  436                      ;*   to stay in the monitor
  996  437                      ;*********************************************************************
  997  438  a00F946 4DCA 08     HaltCmd:     bclr   flagReg,RunFlag ;run/mon flag = 0; monitor active
  998  439  a00F949 86E0                     ldaa  #ErrNone        ;error code for no errors
  999  440  a00F94B 16FC 8C                  jsr    PutChar        ;send error code
 1000  441  a00F94E 8602                     ldaa  #StatHalt       ;status code for Halt command
 1001  442  a00F950 06F8 BE                  jmp    EndPrompt      ;send status and >
 1002  443                      ;*********************************************************************
 1003  444                      ;* Halt or continue user code by Rx interrupt of SCI. User code will 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1004  445                      ;* continue if Run load switch is in run position and a resonable
 1005  446                      ;* Sci user vector is found.
 1006  447                      ;*********************************************************************
 1007  448  a00F953 4F20 4006   SciIsr:      brclr  DBGC1,ARM,SciIsr1 ;Arm not set so continue
 1008  449                      									 ;above must be brclr as COF will be
 1009  450                      									 ;Stored in trace buffer
 1010  451  a00F957 4CCA 20     			 bset   flagReg,ArmFlag  ;Save ARM flag
 1011  452  a00F95A 4D20 40                  bclr   DBGC1,ARM        ;Arm bit in Dbgc1 cleared to stop DBG
 1012  453  a00F95D 1C02 5310   SciIsr1:     bset   SwPullup,mSwPullup ;enable pullup on monitor sw
 1013  454  a00F961 4CCA 08                  bset   flagReg,RunFlag  ;set run/mon flag (run mode)
 1014  455  a00F964 C600        			       ldab  #AllowSci0		 ; defined in the .def file
 1015  456  a00F966 C101        			       cmpb  #$01				 ; is it set?
 1016  457  a00F968 2611        			       bne    SciIsrExit       ; if AllowSci0 is set
 1017  458                      									 ; Test run switch to allow user
 1018  459                      									 ; Sci0 function to run
 1019  460                      ;**********************************************************************
 1020  461                      ;*  Force monitor if SwPort bit SWITCH = 0 
 1021  462                      ;*  Note: this port is configured after reset as input with pull-up
 1022  463                      ;*   if this pin in not connect sci0 will be directed to user sci0
 1023  464                      ;**********************************************************************
 1024  465  a00F96A F602 50                  ldab   SwPort           ;get port value
 1025  466  a00F96D C510                     bitb   #Switch          ;test the sw bit
 1026  467  a00F96F 270A                     beq    SciIsrExit
 1027  468                      ;*********************************************************************
 1028  469                      ;* This routine checks for an unprogrammed SCI0 user interrupt
 1029  470                      ;* vector and returns to monitor if execution of an unprogrammed
 1030  471                      ;* user SCI0 vector is attempted
 1031  472                      ;*********************************************************************
 1032  473  a00F971 FDF7 D6     			       ldy	   $F000+(vector20-BootStart) ; Get user SCI vector
 1033  474  a00F974 8DFF FF                  cpy    #$FFFF			 ;is it programmed?	
 1034  475  a00F977 2702                     beq     SciIsrExit		 ; if not exit
 1035  476  a00F979 0540                     jmp     0,Y			 ;if programmed the go there.
 1036  477                      
 1037  478  a00F97B 1D02 5310   SciIsrExit:  bclr    SwPullup,mSwPullup ;restore reset state
 1038  479  a00F97F 06F8 D4                  jmp     Prompt1
 1039  480                      ;* unlike most ISRs, this one does not end in an RTI. If/when we
 1040  481                      ;* return to running the user program, we will re-enable Rx interrupts
 1041  482                      
 1042  483                      ;*********************************************************************
 1043  484                      ;* Reset Command - forces a reset - if user pseudo-vector is not blank
 1044  485                      ;*  (or some other conditions are met - see ColdStart:) processing will
 1045  486                      ;*  start at the user-specified reset pseudo-vector location and the
 1046  487                      ;*  user has full control of all write-once registers. Otherwise reset
 1047  488                      ;*  causes the bootloader/monitor program to cold start.
 1048  489                      ;*********************************************************************
 1049  490  a00F982 8641        ResetCmd:     ldaa  #RSBCK|!CR2|!CR1|CR0 ;Cop disabled in BDM
 1050  491  a00F984 5A3C                      staa   COPCTL        ; turn on cop monitor
 1051  492  a00F986 913C                      cmpa   COPCTL        ; load to see if user touched it
 1052  493  a00F988 2703                      beq    CopLock       ; wait for COP reset
 1053  494  a00F98A 06F8 00                   jmp    ColdStart     ; can't use COP just start over
 1054  495  a00F98D 1410        CopLock:      orcc  #$10           ; disable interrupts
 1055  496  a00F98F 20FE                      bra	 *
 1056  497                      
 1057  498                      ;*********************************************************************
 1058  499                      ;* SWI service routine - trace1 or breakpoint from user code
 1059  500                      ;*  SWI saves user CPU registers on stack and returns to monitor
 1060  501                      ;*  control at a new command prompt.
 1061  502                      ;*  User CPU registers stack frame...
 1062  503                      ;*
 1063  504                      ;*   +0  UCcr   <- SP after SWI stacking and on entry to this ISR
 1064  505                      ;*   +1  UDreg   (B:A)
 1065  506                      ;*   +3  UXreg
 1066  507                      ;*   +5  UYreg
 1067  508                      ;*   +7  UPc

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1068  509                      ;*   +9  ---     <- User's SP
 1069  510                      ;*********************************************************************
 1070  511  a00F991 7900 28     Breakpoint:  clr    DBGC2            ;Bkpct0 cleared to disabled
 1071  512  a00F994 7900 20                  clr    DBGC1            ;Dbgc1 cleared to disarm DBG
 1072  513  a00F997 4DCA 08                  bclr   flagReg,RunFlag  ;run/mon flag = monitor active
 1073  514  a00F99A C604                     ldab   #StatTrace     ;set status to Trace (SWI) -> B
 1074  515                                                         ;and enter monitor
 1075  516                      
 1076  517                      ;*********************************************************************
 1077  518                      ;* This is the entrypoint to the monitor from the user application
 1078  519                      ;*   A contains the status value that reflects run status
 1079  520                      ;*
 1080  521                      ;* If SP isn't within valid RAM, it can't support the monitor so the
 1081  522                      ;* monitor is forced to initialize the SP and user registers.
 1082  523                      ;*********************************************************************
 1083  524                      ReenterMon:  
 1084  525  a00F99C 8F30 1B     			 cps   #LowSPLimit+1  ;check against lower limit
 1085  526  a00F99F 2518                     blo    badSP         ; note: +1 => A is not pushed yet
 1086  527  a00F9A1 8F3F F8                  cps   #HighSPLimit+1 ;check against upper limit
 1087  528  a00F9A4 2213                     bhi    badSP
 1088  529  a00F9A6 86E0                     ldaa  #ErrNone       ;error code for no errors
 1089  530  a00F9A8 16FC 8C                  jsr    PutChar       ;send error code
 1090  531  a00F9AB 180F                     tba                  ;status code from B to A
 1091  532  a00F9AD 4FCA 0405                brclr  flagReg,TraceFlag,SWIdone  ;0 indicates not Trace
 1092  533  a00F9B1 4DCA 04                  bclr   flagReg,TraceFlag  ;acknowledge trace flag
 1093  534  a00F9B4 8604                     ldaa  #StatTrace     ;status code for Trace1 return
 1094  535  a00F9B6 06F8 BE     SWIdone:     jmp    EndPrompt     ;send status and >
 1095  536  a00F9B9 86E3        badSP:       ldaa  #ErrSP         ;set error code to bad stack pointer
 1096  537  a00F9BB 06F8 69                  jmp    stackInit
 1097  538  a00F9BE 4DCA 20                  bclr   flagReg,ArmFlag  ;Save ARM flag
 1098  539                      
 1099  540                      ;*********************************************************************
 1100  541                      ;* Erase EE Command -  mass
 1101  542                      ;*  erase all EEPROM locations
 1102  543                      ;*
 1103  544                      ;* Eeprom erasure assumes no protection. (Mass command will fail)
 1104  545                      ;*********************************************************************
 1105  546  a00F9C1 16FD 34     EraseEECmd:  jsr    abClr         ;abort commands and clear errors
 1106  547                      
 1107  548  a00F9C4 4F1C 3026                brclr  MEMSIZ0,eep_sw1+eep_sw0,ErsPageErr1  ;Check if device has EEprom
 1108  549  a00F9C8 CD00 00                  ldy   #EEpromStart   ; get device eeprom start
 1109  550  a00F9CB 6C40                     std    0,y           ; write to eeprom (latch address)
 1110  551                                                        ; data is don't care (but needed)
 1111  552                      
 1112  553  a00F9CD 180B 4101                movb  #$41,ECMD      ;mass erase command
             00F9D1 16         
 1113  554  a00F9D2 180B 8001                movb  #CBEIF,ESTAT   ;register the command
             00F9D6 15         
 1114  555  a00F9D7 A7                       nop                  ; wait a few cycles for
 1115  556  a00F9D8 A7                       nop                  ; command to sync.
 1116  557  a00F9D9 A7                       nop
 1117  558  a00F9DA B601 15     ChkDoneE:    ldaa   ESTAT         ;wait for CBEIF=CCIF=1 (cmnd done)
 1118  559  a00F9DD 2AFB                     bpl    ChkDoneE      ;loop if command buffer full (busy)
 1119  560  a00F9DF 48                       asla                 ;moves CCIF to MSB (set/clear N bit)
 1120  561  a00F9E0 2AF8                     bpl    ChkDoneE      ;loop if CCIF=0 (not done)
 1121  562  a00F9E2 B601 05                  ldaa   FSTAT
 1122  563  a00F9E5 8430                     anda  #$30           ;mask all but PVIOL or ACCERR
 1123  564  a00F9E7 2605                     bne    ErsPageErr1   ;back to prompt-flash error
 1124  565  a00F9E9 86E0                     ldaa   #ErrNone      ;code for no errors ($E0)
 1125  566  a00F9EB 06F8 B4                  jmp    Prompt        ;ready for next command
 1126  567                      
 1127  568  a00F9EE 86E9        ErsPageErr1: ldaa   #ErrEeErase   ;Erase error code ($E9)
 1128  569  a00F9F0 06F8 B4                  jmp    Prompt        ;ready for next command
 1129  570                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1130  571                      ;*********************************************************************
 1131  572                      ;* Erase Command - Use repeated page erase commands to erase all flash
 1132  573                      ;*  except bootloader in protected block at the end of flash, and mass
 1133  574                      ;*  erase all EEPROM locations
 1134  575                      ;*
 1135  576                      ;* Eeprom erasure assumes no protection. (Mass command will fail)
 1136  577                      ;*********************************************************************
 1137  578  a00F9F3 16FD 34     EraseAllCmd: jsr    abClr         ;abort commands and clear errors
 1138  579                      
 1139  580  a00F9F6 4F1C 301A                brclr  MEMSIZ0,eep_sw1+eep_sw0,ErsBlk0  ;Check if device has EEprom
 1140  581  a00F9FA CD00 00                  ldy   #EEpromStart   ; get device eeprom start
 1141  582  a00F9FD 6C40                     std    0,y           ; write to eeprom (latch address)
 1142  583                                                        ; data is don't care (but needed)
 1143  584                      
 1144  585  a00F9FF 180B 4101                movb  #MassErase,ECMD      ;mass erase command
             00FA03 16         
 1145  586  a00FA04 180B 8001                movb  #CBEIF,ESTAT   ;register the command
             00FA08 15         
 1146  587  a00FA09 A7                       nop                  ; wait a few cycles for
 1147  588  a00FA0A A7                       nop                  ; command to sync.
 1148  589  a00FA0B A7                       nop
 1149  590  a00FA0C B601 15     ChkDoneE1:   ldaa   ESTAT         ;wait for CBEIF=CCIF=1 (cmnd done)
 1150  591  a00FA0F 2AFB                     bpl    ChkDoneE1     ;loop if command buffer full (busy)
 1151  592  a00FA11 48                       asla                 ;moves CCIF to MSB (set/clear N bit)
 1152  593  a00FA12 2AF8                     bpl    ChkDoneE1     ;loop if CCIF=0 (not done)
 1153  594                      ;
 1154  595                      ; erase flash pages from RomStart to start of protected bootloader
 1155  596                      ; no need to check for errors because we cleared them before EE erase
 1156  597                      ;
 1157  598                      
 1158  599  a00FA14 D630        ErsBlk0:     ldab  PPAGE           ;	 Move PPAGE to Stack for storage
 1159  600  a00FA16 37                       pshb
 1160  601                                           ; sector erase all full blocks
 1161  602  a00FA17 C608                     ldab   #PagesBlk     ; Get number of banks/blocks
 1162  603  a00FA19 53                       decb                 ; erase all but last
 1163  604  a00FA1A 6BAF                     stab   1,-sp         ; save counter
 1164  605  a00FA1C 863F                     ldaa   #$3f          ; highest bank
 1165  606  a00FA1E 1816                     sba                  ; Compute lowest page-1
 1166  607  a00FA20 5A30                     staa   PPAGE         ; PPAGE for first 16K page of block 0
 1167  608                                                        ; (passed in the A accumulator).
 1168  609  a00FA22 7901 03                  clr    FCNFG         ; set block select bits to 0.
 1169  610  a00FA25 CE04 00     ErsBlk0Lp:   ldx    #SectorSize   ; select sector size
 1170  611  a00FA28 CC40 00                  ldd    #$4000        ; Window size
 1171  612  a00FA2B 1810                     idiv                 ; compute total number of sectors
 1172  613  a00FA2D B754                     tfr    x,d           ; get number of sectors in B
 1173  614  a00FA2F CE80 00                  ldx   #Window        ; point to the start of the PPAGE window.
 1174  615  a00FA32 075E                     bsr    ErsSectors    ; go erase the PPAGE window a sector at a time.
 1175  616  a00FA34 7200 30                  inc    PPAGE         ; go to the next PPAGE.
 1176  617  a00FA37 6380                     dec    0,sp          ; done with all full PPAGE blocks?
 1177  618  a00FA39 26EA                     bne    ErsBlk0Lp     ;   no? then erase more blocks.
 1178  619                      
 1179  620  a00FA3B CE04 00                  ldx    #SectorSize   ; select sector size
 1180  621  a00FA3E CC38 00                  ldd    #((BootStart-$c000)) ; get size - protected amount
 1181  622  a00FA41 1810                     idiv                 ; compute total number of sectors
 1182  623                                                        ; minus the bootblock.
 1183  624  a00FA43 B754                     tfr    x,d           ; get number of sectors in B
 1184  625  a00FA45 CE80 00                  ldx   #Window        ; point to the start of the PPAGE window.
 1185  626  a00FA48 0748                     bsr    ErsSectors    ; go erase the PPAGE window a sector at a time.
 1186  627  a00FA4A 33                       pulb                 ; remove the page count from the stack.
 1187  628                      
 1188  629                      ; erase all sectors outside the bootblock.
 1189  630                      ;
 1190  631                      ;********************************************************************
 1191  632                      ;bulk erase all the rest

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1192  633                      ;********************************************************************
 1193  634                      
 1194  635  a00FA4B C601                     ldab  #FlashBlks     ; select lowest page of the highest bank
 1195  636  a00FA4D 53                       decb                 ;
 1196  637  a00FA4E 271F                     beq    EraseDone     ; if single block device quit
 1197  638  a00FA50 C638                     ldab  #LowestPage    ; select lowest bank
 1198  639  a00FA52 5B30        BlockLoop:   stab   PPAGE         ; must match array selection
 1199  640  a00FA54 54                       lsrb                 ; calculate the value of the block select bits based
 1200  641  a00FA55 54                       lsrb                 ; on bits 3:2 of the PPAGE register value. (<256k)
 1201  642  a00FA56 CD04 00                  ldy   #SectorSize    ; get high byte of size
 1202  643  a00FA59 8D02 00                  cpy   #$0200         ; if larger than $200 shift again
 1203  644  a00FA5C 2701                     beq    nBlockLoop    ; otherwise skip ahead
 1204  645  a00FA5E 54                       lsrb                 ; on bits 4:3 of the PPAGE register value. (512k)
 1205  646  a00FA5F 51          nBlockLoop:  comb
 1206  647  a00FA60 C403                     andb  #$03           ; mask off all but the lower 2 bits.
 1207  648  a00FA62 7B01 03                  stab   FCNFG         ; select the block to erase.
 1208  649  a00FA65 070E                     bsr    BulkErase     ; erase it
 1209  650  a00FA67 D630                     ldab   PPAGE         ;get ppage back
 1210  651  a00FA69 CB08                     addb  #PagesBlk      ;
 1211  652  a00FA6B C137                     cmpb  #($3F-PagesBlk) ; see if last block
 1212  653  a00FA6D 2BE3                     bmi    BlockLoop
 1213  654                      
 1214  655  a00FA6F 33          EraseDone:   pulb
 1215  656  a00FA70 5B30                     stab  PPAGE           ;	 Move PPAGE from Stack
 1216  657                      
 1217  658  a00FA72 06F8 B2     OkCommand:   jmp    CommandOK     ;back to no error and prompt
 1218  659                      
 1219  660  a00FA75 34          BulkErase:   pshx                 ;save address
 1220  661  a00FA76 CE80 00                  ldx    #Window       ;must point into bank
 1221  662  a00FA79 6A00                     staa   ,x            ;latch address to erase
 1222  663  a00FA7B 180B 4101                movb  #MassErase,FCMD      ; Select mass erase
             00FA7F 06         
 1223  664  a00FA80 180B 8001                movb  #CBEIF,FSTAT   ;register the command
             00FA84 05         
 1224  665  a00FA85 A7                       nop                  ;wait a few cycles for
 1225  666  a00FA86 A7                       nop                  ;command to sync.
 1226  667  a00FA87 A7                       nop
 1227  668  a00FA88 B601 05     ChkDoneF:    ldaa   FSTAT         ;wait for CBEIF=CCIF=1 (cmnd done)
 1228  669  a00FA8B 2AFB                     bpl    ChkDoneF      ;loop if command buffer full (busy)
 1229  670  a00FA8D 48                       asla                 ;moves CCIF to MSB (set/clear N bit)
 1230  671  a00FA8E 2AF8                     bpl    ChkDoneF      ;loop if CCIF=0 (not done)
 1231  672  a00FA90 30                       pulx                 ;get address back
 1232  673  a00FA91 3D                       rts
 1233  674                      ;Erase 'b' (accumulator) sectors beginning at address 'x' (index register)
 1234  675                      ;
 1235  676  a00FA92 B796        ErsSectors:  exg    b,y           ;put the sector count in y.
 1236  677  a00FA94 6C00        ErsSectLp:   std    ,x
 1237  678  a00FA96 180B 4001                movb  #SecErase,FCMD ;perform a sector erase.
             00FA9A 06         
 1238  679  a00FA9B 16FD A3                  jsr    DoOnStack     ;finish command from stack-based sub
 1239  680  a00FA9E 97                       tsta                 ;check for 0=OK
 1240  681  a00FA9F 2608                     bne    ErsSectErr    ;back to prompt-flash erase error
 1241  682  a00FAA1 1AE2 0400                leax   SectorSize,x  ;point to the next sector.
 1242  683  a00FAA5 0436 EC                  dbne   y,ErsSectLp   ;continue to erase remaining sectors.
 1243  684  a00FAA8 3D                       rts
 1244  685                      
 1245  686  a00FAA9 3A          ErsSectErr:  puld                 ; clear stack
 1246  687  a00FAAA 204A                     bra    ErsPageErr
 1247  688                      
 1248  689  a00FAAC 16FD 34     ErsPage:     jsr    abClr         ; abort commands and clear errors
 1249  690  a00FAAF D630        	           ldab   PPAGE         ; get current ppage
 1250  691                      
 1251  692  a00FAB1 54                       lsrb                 ; calculate the value of the block select bits based
 1252  693  a00FAB2 54                       lsrb                 ; on bits 3:2 of the PPAGE register value. (<256k)

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1253  694  a00FAB3 CD04 00                  ldy   #SectorSize    ; get high byte of size
 1254  695  a00FAB6 8D02 00                  cpy   #$0200         ; if larger than $200 shift again
 1255  696  a00FAB9 2701                     beq    ErsPage1      ; otherwise skip ahead
 1256  697  a00FABB 54                       lsrb                 ; on bits 4:3 of the PPAGE register value. (512k)
 1257  698  a00FABC 51          ErsPage1:    comb
 1258  699  a00FABD C403                     andb  #$03           ; mask off all but the lower 2 bits.
 1259  700  a00FABF 7B01 03                  stab   FCNFG         ; select the block to erase.
 1260  701  a00FAC2 D630                     ldab   PPAGE         ; get current ppage
 1261  702  a00FAC4 C13F                     cmpb  #$3F		      ; is it the page with the monitor
 1262  703  a00FAC6 2611                     bne   ErsFullPage    ; no then erase all of page
 1263  704  a00FAC8 CE04 00                  ldx   #SectorSize    ; select sector size
 1264  705  a00FACB CC38 00                  ldd   #((BootStart-$c000)) ; get size - protected amount
 1265  706  a00FACE 1810                     idiv                 ; compute total number of sectors
 1266  707                                                        ; minus the bootblock.
 1267  708  a00FAD0 B754                     tfr    x,d           ; get number of sectors in B
 1268  709  a00FAD2 CE80 00                  ldx   #Window        ; point to the start of the PPAGE window.
 1269  710  a00FAD5 07BB                     bsr    ErsSectors    ; go erase the PPAGE window a sector at a time.
 1270  711  a00FAD7 2011                     bra    EraPageStat   ; back to no error and prompt
 1271  712                      
 1272  713  a00FAD9 CE04 00     ErsFullPage: ldx   #SectorSize    ; select sector size
 1273  714  a00FADC CC40 00                  ldd   #$4000         ; Window size
 1274  715  a00FADF 1810                     idiv                 ; compute total number of sectors
 1275  716  a00FAE1 B754                     tfr    x,d           ; get number of sectors in B
 1276  717  a00FAE3 CE80 00                  ldx   #Window        ; point to the start of the PPAGE window.
 1277  718  a00FAE6 07AA                     bsr    ErsSectors    ; go erase the PPAGE window a sector at a time.
 1278  719  a00FAE8 2000                     bra    EraPageStat     ;back to no error and prompt
 1279  720                      
 1280  721  a00FAEA B601 05     EraPageStat: ldaa   FSTAT
 1281  722  a00FAED 8430                     anda  #$30           ;mask all but PVIOL or ACCERR
 1282  723  a00FAEF 2605                     bne    ErsPageErr    ;back to prompt-flash error
 1283  724  a00FAF1 86E0                     ldaa   #ErrNone      ;code for no errors ($E0)
 1284  725  a00FAF3 06F8 B4                  jmp    Prompt        ;ready for next command
 1285  726                      
 1286  727  a00FAF6 86E6        ErsPageErr: ldaa   #ErrFlash      ;code for Flash error ($E6)
 1287  728  a00FAF8 06F8 B4                  jmp    Prompt        ;ready for next command
 1288  729                      
 1289  730                      ;*********************************************************************
 1290  731                      ;* Read Byte Command - read specified address and return the data
 1291  732                      ;*  8-bit command code from host to SCI0 RxD
 1292  733                      ;*  16-bit address (high byte first) from host to SCI0 RxD
 1293  734                      ;*  8-bit data sent back to host through SCI0 TxD
 1294  735                      ;*********************************************************************
 1295  736  a00FAFB 16FC 78     RdByteCmd:   jsr    getX          ;get address to read from
 1296  737  a00FAFE A600                     ldaa   ,x            ;read the requested location
 1297  738  a00FB00 16FC 8C                  jsr    PutChar       ;send it out SCI0
 1298  739  a00FB03 06F8 B2                  jmp    CommandOK     ;ready for next command
 1299  740                      
 1300  741                      ;*********************************************************************
 1301  742                      ;* Read Word Command - read specified block of data
 1302  743                      ;*  8-bit command code from host to SCI0 RxD
 1303  744                      ;*  16-bit address (high byte first) from host to SCI0 RxD
 1304  745                      ;*  16-bit number sent back to host through SCI0 TxD
 1305  746                      ;* Special case of block read.
 1306  747                      ;*********************************************************************
 1307  748  a00FB06 16FC 78     RdWordCmd:   jsr    getX          ;get address to read from
 1308  749  a00FB09 EC00        sendExit:    ldd    ,x            ;read the requested location
 1309  750  a00FB0B 16FC 8C                  jsr    PutChar       ;send it out SCI0
 1310  751  a00FB0E 180F                     tba
 1311  752  a00FB10 16FC 8C                  jsr    PutChar       ;send it out SCI0
 1312  753  a00FB13 06F8 B2                  jmp    CommandOK     ;ready for next command
 1313  754                                   
 1314  755                      ;*********************************************************************
 1315  756                      ;* Read Command - read specified block of data
 1316  757                      ;*  8-bit command code from host to SCI0 RxD

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1317  758                      ;*  16-bit address (high byte first) from host to SCI0 RxD
 1318  759                      ;*  8-bit number of bytes-1 to sent back to host through SCI0 TxD
 1319  760                      ;*********************************************************************
 1320  761  a00FB16 16FC 78     ReadCmd:     jsr    getX          ;get address to read from
 1321  762  a00FB19 16FC 83                  jsr    GetChar       ;get number of bytes to read
 1322  763  a00FB1C 180E                     tab
 1323  764  a00FB1E 52                       incb                 ;correct counter (0 is actually 1)
 1324  765  a00FB1F A600        ReadNext:    ldaa   ,x            ;read the requested location
 1325  766  a00FB21 16FC 8C     			 jsr    PutChar       ;send it out SCI0
 1326  767  a00FB24 08                       inx
 1327  768  a00FB25 53                       decb   
 1328  769  a00FB26 26F7                     bne    ReadNext             
 1329  770  a00FB28 86E0                     ldaa  #ErrNone       ;code for no errors ($E0)
 1330  771  a00FB2A 06F8 B4     xPrompt:     jmp    Prompt        ;ready for next command
 1331  772                      
 1332  773                      ;*********************************************************************
 1333  774                      ;* Write Command - write specified block of data
 1334  775                      ;*  8-bit command code from host to SCI0 RxD
 1335  776                      ;*  16-bit address (high byte first) from host to SCI0 RxD
 1336  777                      ;*  8-bit number of bytes-1 to write from host to SCI0 TxD
 1337  778                      ;*  8-bit values to write
 1338  779                      ;* this function used Word writes whenever possible. This is:
 1339  780                      ;* a) when more than one byte is still to write
 1340  781                      ;* b) and the address is even
 1341  782                      ;*********************************************************************
 1342  783  a00FB2D 16FC 78     WriteCmd:    jsr    getX          ;get address to write to
 1343  784  a00FB30 16FC 83                  jsr    GetChar       ;get number of bytes to read
 1344  785  a00FB33 180E                     tab
 1345  786  a00FB35 52                       incb                 ;correct counter (0 is actually 1)
 1346  787  a00FB36 C101        WriteNext:   cmpb   #1            ;if only one byte left
 1347  788  a00FB38 37                       pshb                 ;preserve byte counter
 1348  789  a00FB39 271B                     beq    WriteByte     ;write it 
 1349  790  a00FB3B B750                     tfr    x,a           ;is address odd
 1350  791  a00FB3D 8501                     bita   #1
 1351  792  a00FB3F 2615                     bne    WriteByte     ;write a byte first
 1352  793                                   
 1353  794  a00FB41 16FC 83     WriteWord:   jsr    GetChar       ;get high byte
 1354  795  a00FB44 180E                     tab                  ;save in B
 1355  796  a00FB46 6380                     dec    ,sp           ;decrement byte counter (on stack)
 1356  797  a00FB48 16FC 83                  jsr    GetChar       ;get low byte
 1357  798  a00FB4B B781                     exg    a,b           ;flip high and low byte
 1358  799  a00FB4D 16FC C2                  jsr    WriteD2IX     ;write or program data to address
 1359  800  a00FB50 33                       pulb                 ;restore byte counter                
 1360  801  a00FB51 2617                     bne    WriteError    ;error detected
 1361  802  a00FB53 08                       inx                  ;increment target address
 1362  803  a00FB54 2009                     bra    Write1         
 1363  804                      
 1364  805  a00FB56 16FC 83     WriteByte:   jsr    GetChar       ;get data to write
 1365  806  a00FB59 16FC E4                  jsr    WriteA2IX     ;write or program data to address
 1366  807  a00FB5C 33                       pulb                 ;restore byte counter       
 1367  808  a00FB5D 260B                     bne    WriteError    ;error detected
 1368  809  a00FB5F 08          Write1:      inx                  ;increment target address
 1369  810  a00FB60 53                       decb                 ;decrement byte counter 
 1370  811  a00FB61 26D3                     bne    WriteNext
 1371  812  a00FB63 86E0                     ldaa   #ErrNone      ;code for no errors ($E0)             
 1372  813  a00FB65 20C3                     bra    xPrompt       ;then back to prompt
 1373  814                                       
 1374  815  a00FB67 16FC 83     SkipBytes:   jsr    GetChar       ;read remaining bytes                               
 1375  816  a00FB6A 53          WriteError:  decb                 ;
 1376  817  a00FB6B 26FA                     bne    SkipBytes                           
 1377  818  a00FB6D 86E6                     ldaa   #ErrFlash     ;code for Flash error ($E6)
 1378  819  a00FB6F 20B9        WriteDone:   bra    xPrompt       ;then back to prompt
 1379  820                      
 1380  821                      ;*********************************************************************

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1381  822                      ;* Read Next Command - IX=IX+2; read m(IX,IX=1) and return the data
 1382  823                      ;*  8-bit command code from host to SCI0 RxD
 1383  824                      ;*  16-bit data sent back to host through SCI0 TxD
 1384  825                      ;*  uses current value of IX from user CPU regs stack frame
 1385  826                      ;*********************************************************************
 1386  827  a00FB71 4FCA 080C   RdNextCmd:   brclr  flagReg,RunFlag,notRun  ;do command if not run
 1387  828  a00FB75 87                       clra                 ;data = $00 (can't read real data)
 1388  829  a00FB76 16FC 8C                  jsr    PutChar       ;send $00 instead of read_next data
 1389  830  a00FB79 16FC 8C                  jsr    PutChar       ;send $00 instead of read_next data
 1390  831  a00FB7C 86E2                     ldaa   #ErrRun       ;code for run mode error
 1391  832  a00FB7E 06F8 B4     xCmnd:       jmp    Prompt        ;back to prompt; run error
 1392  833  a00FB81 0738        notRun:      bsr    preInc        ;get, pre-inc, & update user IX
 1393  834  a00FB83 06FB 09                  jmp    sendExit      ;get data, send it, & back to prompt
 1394  835                      
 1395  836                      ;*********************************************************************
 1396  837                      ;* Write Byte Command - write specified address with specified data
 1397  838                      ;*  8-bit command code from host to SCI0 RxD
 1398  839                      ;*  16-bit address (high byte first) from host to SCI0 RxD
 1399  840                      ;*  8-bit data from host to SCI0 RxD
 1400  841                      ;*********************************************************************
 1401  842  a00FB86 16FC 78     WtByteCmd:   jsr    getX          ;get address to write to
 1402  843  a00FB89 16FC 83     WriteNext2:  jsr    GetChar       ;get data to write
 1403  844  a00FB8C 16FC 93                  jsr    CheckModule
 1404  845  a00FB8F 2702                     beq    isRAMbyte
 1405  846  a00FB91 2008                     bra    WriteByteNVM  ;deny access (byte NVM access)
 1406  847                      
 1407  848  a00FB93 6A00        isRAMbyte:   staa   0,x           ;write to RAM or register
 1408  849  a00FB95 87                       clra                 ;force Z=1 to indicate OK
 1409  850                      
 1410  851  a00FB96 86E0        WriteExit:   ldaa  #ErrNone       ;code for no errors ($E0)
 1411  852  a00FB98 06F8 B4                  jmp    Prompt        ;ready for next command
 1412  853                      
 1413  854  a00FB9B 86E5        WriteByteNVM: ldaa #ErrByteNVM    ;code for byte NVM error ($E5)
 1414  855  a00FB9D 06F8 B4                  jmp    Prompt        ;ready for next command
 1415  856                      
 1416  857                      
 1417  858                      ;*********************************************************************
 1418  859                      ;* Write Word Command - write word of data
 1419  860                      ;*  8-bit command code from host to SCI0 RxD
 1420  861                      ;*  16-bit address (high byte first) from host to SCI0 RxD
 1421  862                      ;*  16-bit value to write
 1422  863                      ;*********************************************************************
 1423  864  a00FBA0 16FC 78     WtWordCmd:   jsr    getX          ;get address to write to
 1424  865  a00FBA3 C602        			 ldab  #02            ;one word +1
 1425  866  a00FBA5 37          			 pshb				  ;save it on stack
 1426  867  a00FBA6 2099                     bra    WriteWord     ;get & write data, & back to prompt
 1427  868                                   
 1428  869                      ;*********************************************************************
 1429  870                      ;* Write Next Command - IX=IX+1; write specified data to m(IX)
 1430  871                      ;*  8-bit command code from host to SCI0 RxD
 1431  872                      ;*  16-bit data from host to SCI0 RxD
 1432  873                      ;*
 1433  874                      ;*  uses current value of IX from user CPU regs stack frame
 1434  875                      ;*********************************************************************
 1435  876  a00FBA8 4FCA 0808   WtNextCmd:   brclr  flagReg,RunFlag,notRunW  ;do command if not run
 1436  877  a00FBAC 16FC 78                  jsr    getX          ;clear data
 1437  878  a00FBAF 86E2                     ldaa   #ErrRun       ;code for run mode error
 1438  879  a00FBB1 06F8 B4     xCmndW:      jmp    Prompt        ;back to prompt; run error
 1439  880                      
 1440  881  a00FBB4 0705        notRunW:     bsr    preInc        ;get, pre-inc, & update user IX
 1441  882  a00FBB6 C602        			 ldab  #02            ;one word +1
 1442  883  a00FBB8 37          			 pshb				  ;save it on stack
 1443  884  a00FBB9 2086                     bra    WriteWord     ;get & write data, & back to prompt
 1444  885                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1445  886                      ;*********************************************************************
 1446  887                      ;* utility to get IX from stack frame and pre increment it by 2
 1447  888                      ;* assumes interrupts are blocked while in monitor
 1448  889                      ;*********************************************************************
 1449  890  a00FBBB 1B82        preInc:      leas 2,sp
 1450  891  a00FBBD EE83                     ldx    UXreg,sp      ;get user X
 1451  892  a00FBBF 08                       inx                  ;pre-increment
 1452  893  a00FBC0 08                       inx                  ;pre-increment
 1453  894  a00FBC1 6E83                     stx    UXreg,sp      ;put adjusted user X back on stack
 1454  895  a00FBC3 1B9E                     leas -2,sp
 1455  896  a00FBC5 3D                       rts                  ;pre-incremented IX still in IX
 1456  897                      
 1457  898                      ;*********************************************************************
 1458  899                      ;* Read Registers Command - read user's CPU register values
 1459  900                      ;*
 1460  901                      ;*  16-bit SP value (high byte first) sent to host through SCI0 TxD
 1461  902                      ;*  16-bit PC value (high byte first) sent to host through SCI0 TxD
 1462  903                      ;*  16-bit IY value (high byte first) sent to host through SCI0 TxD
 1463  904                      ;*  16-bit IX value (high byte first) sent to host through SCI0 TxD
 1464  905                      ;*  16-bit D  value (high byte first) sent to host through SCI0 TxD
 1465  906                      ;*   8-bit CCR value sent to host through SCI0 TxD
 1466  907                      ;*
 1467  908                      ;* User CPU registers stack frame...
 1468  909                      ;*
 1469  910                      ;*   +0  UCcr   <- Monitor's SP
 1470  911                      ;*   +1  UDreg   (B:A)
 1471  912                      ;*   +3  UXreg
 1472  913                      ;*   +5  UYreg
 1473  914                      ;*   +7  UPc
 1474  915                      ;*   +9  ---     <- User's SP
 1475  916                      ;*********************************************************************
 1476  917  a00FBC6 B775        RdRegsCmd:   tsx                  ;IX = Monitor SP +2
 1477  918  a00FBC8 1A09                     leax   SPOffset,x    ;correct SP value
 1478  919  a00FBCA 16FC 6F                  jsr    put16         ;send user SP out SCI0
 1479  920  a00FBCD EE87                     ldx    UPc,sp        ;user PC to IX
 1480  921  a00FBCF 16FC 6F                  jsr    put16         ;send user PC out SCI0
 1481  922  a00FBD2 EE85                     ldx    UYreg,sp      ;user IY to IX
 1482  923  a00FBD4 16FC 6F                  jsr    put16         ;send user IY out SCI0
 1483  924  a00FBD7 EE83                     ldx    UXreg,sp      ;user IX to IX
 1484  925  a00FBD9 16FC 6F                  jsr    put16         ;send user IX out SCI0
 1485  926  a00FBDC EE81                     ldx    UDreg,sp      ;user D to IX
 1486  927  a00FBDE B7C5                     exg    d,x
 1487  928  a00FBE0 B781                     exg    a,b           ;flip as D is stacked B:A
 1488  929  a00FBE2 B7C5                     exg    d,x
 1489  930  a00FBE4 16FC 6F                  jsr    put16         ;send user D out SCI0
 1490  931  a00FBE7 A680                     ldaa   UCcr,sp       ;user CCR to A
 1491  932  a00FBE9 16FC 8C                  jsr    PutChar       ;send user CCR out SCI0
 1492  933  a00FBEC 06F8 B2                  jmp    CommandOK     ;back to prompt
 1493  934                      
 1494  935                      ;*********************************************************************
 1495  936                      ;* Write CCR Command - write user's CCR register value
 1496  937                      ;*  8-bit command code from host to SCI0 RxD
 1497  938                      ;*  8-bit data for CCR from host to SCI0 RxD
 1498  939                      ;*********************************************************************
 1499  940  a00FBEF 16FC 83     WriteCcrCmd: jsr    GetChar       ;read new CCR value
 1500  941  a00FBF2 6A80                     staa   UCcr,sp       ;replace user CCR value
 1501  942  a00FBF4 06F8 B2                  jmp    CommandOK     ;back to no error and prompt
 1502  943                      
 1503  944                      ;*********************************************************************
 1504  945                      ;* Write D Command - write user's D register value
 1505  946                      ;*  8-bit command code from host to SCI0 RxD
 1506  947                      ;*  16-bit data (high byte first) for D from host to SCI0 RxD
 1507  948                      ;*********************************************************************
 1508  949  a00FBF7 16FC 78     WriteDCmd:   jsr    getX          ;read new D value

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1509  950  a00FBFA B7C5                     exg    d,x
 1510  951  a00FBFC B781                     exg    a,b           ;flip as D is stacked B:A
 1511  952  a00FBFE B7C5                     exg    d,x
 1512  953  a00FC00 6E81                     stx    UDreg,sp      ;replace user D value
 1513  954  a00FC02 06F8 B2                  jmp    CommandOK     ;back to no error and prompt
 1514  955                      
 1515  956                      ;*********************************************************************
 1516  957                      ;* Write IX Command - write user's IX register value
 1517  958                      ;*  8-bit command code from host to SCI0 RxD
 1518  959                      ;*  16-bit data (high byte first) for IX from host to SCI0 RxD
 1519  960                      ;*********************************************************************
 1520  961  a00FC05 16FC 78     WriteIXCmd:  jsr    getX          ;read new IX value
 1521  962  a00FC08 6E83                     stx    UXreg,sp      ;replace user IX value
 1522  963  a00FC0A 06F8 B2                  jmp    CommandOK     ;back to no error and prompt
 1523  964                      
 1524  965                      ;*********************************************************************
 1525  966                      ;* Write IY Command - write user's IY register value
 1526  967                      ;*  8-bit command code from host to SCI0 RxD
 1527  968                      ;*  16-bit data (high byte first) for IY from host to SCI0 RxD
 1528  969                      ;*********************************************************************
 1529  970  a00FC0D 16FC 78     WriteIYCmd:  jsr    getX          ;read new IY value
 1530  971  a00FC10 6E85                     stx    UYreg,sp      ;replace user IY value
 1531  972  a00FC12 06F8 B2                  jmp    CommandOK     ;back to no error and prompt
 1532  973                      
 1533  974                      ;*********************************************************************
 1534  975                      ;* Write PC Command - write user's PC register value
 1535  976                      ;*  8-bit command code from host to SCI0 RxD
 1536  977                      ;*  16-bit data (high byte first) for PC from host to SCI0 RxD
 1537  978                      ;*********************************************************************
 1538  979  a00FC15 16FC 78     WritePcCmd:  jsr    getX          ;read new PC thru SCI0 to IX
 1539  980  a00FC18 6E87                     stx    UPc,sp       ;replace user PC value
 1540  981  a00FC1A 06F8 B2                  jmp    CommandOK     ;back to no error and prompt
 1541  982                      
 1542  983                      ;*********************************************************************
 1543  984                      ;* Write SP Command - write user's SP register value
 1544  985                      ;*  8-bit command code from host to SCI0 RxD
 1545  986                      ;*  16-bit data (high byte first) for SP from host to SCI0 RxD
 1546  987                      ;*
 1547  988                      ;*  Since other user CPU register values are stored on the stack, the
 1548  989                      ;*  host will need to re-write the other user registers after SP is
 1549  990                      ;*  changed. This routine just changes SP itself.
 1550  991                      ;*
 1551  992                      ;*  SP value is user's SP & it is adjusted (-10) to accommodate the
 1552  993                      ;*  user CPU register stack frame.
 1553  994                      ;*
 1554  995                      ;*  If the host attempts to set the user SP value <RamStart or >RamLast
 1555  996                      ;*  then the change is ignored, because such values would not support
 1556  997                      ;*  proper execution of the monitor firmware.
 1557  998                      ;*********************************************************************
 1558  999  a00FC1D 0759        WriteSpCmd:  bsr    getX         ;new SP value now in IX
 1559 1000  a00FC1F 1A17                     leax  -SPOffset,x   ;correct SP value
 1560 1001  a00FC21 8E30 1A                  cpx   #LowSPLimit   ;check against lower limit
 1561 1002  a00FC24 250A                     blo    spBad
 1562 1003  a00FC26 8E3F F7                  cpx   #HighSPLimit  ;check against upper limit
 1563 1004  a00FC29 2205                     bhi    spBad
 1564 1005  a00FC2B B757                     txs                 ;IX -> SP
 1565 1006  a00FC2D 06F8 B2                  jmp    CommandOK    ;back to no error and prompt
 1566 1007  a00FC30 86E4        spBad:       ldaa    #ErrWriteSP      ;error code for stack errors
 1567 1008                      ;             bsr    PutChar      ;send error code
 1568 1009  a00FC32 06F8 B4                  jmp    Prompt       ;send status and >
 1569 1010                      
 1570 1011                      ;*********************************************************************
 1571 1012                      ;* Trace 1 Command - trace one user instruction starting at current PC
 1572 1013                      ;*  8-bit command code from host to SCI0 RxD

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1573 1014                      ;*
 1574 1015                      ;*  if an interrupt was already pending, the user PC will point at the
 1575 1016                      ;*  ISR after the trace and the opcode at the original address will
 1576 1017                      ;*  not have been executed. (because the interrupt response is
 1577 1018                      ;*  considered to be an instruction to the CPU)
 1578 1019                      ;*********************************************************************
 1579 1020                      ;
 1580 1021  a00FC35 3D          pagebits:   fcb      $3D		;$0000-$3FFF is PPAGE $3D
 1581 1022  a00FC36 3E                      fcb      $3E		;$4000-$7FFF is PPAGE $3E
 1582 1023  a00FC37 3F                      fcb      $3F		;$C000-$FFFF is PPAGE $3F
 1583 1024                      pagebitsaddr:
 1584 1025  a00FC38 FC35                    fdb     pagebits     ;$0000-$3FFF : Use constant $3D
 1585 1026  a00FC3A FC36                    fdb     pagebits+1   ;$4000-$7FFF : Use constant $3E (2nd last page)
 1586 1027  a00FC3C 0030                    fdb     $0030        ;$8000-$BFFF : Use window PPAGE
 1587 1028  a00FC3E FC37                    fdb     pagebits+2   ;$C000-$FFFF : Use constant $3F (last page)
 1588 1029                      Trace1Cmd:
 1589 1030  a00FC40 4CCA 04                 bset    flagReg,TraceFlag  ;so at SWI we know it was Trace
 1590 1031  a00FC43 EE87                    ldx     UPc,sp       ;PC of go address
 1591 1032  a00FC45 08                      inx                  ;IX points at go opcode +1
 1592 1033  a00FC46 08                      inx                  ;IX points at go opcode +2
 1593 1034  a00FC47 B7C5         	        xgdx
 1594 1035  a00FC49 C4FE                    andb   #$FE
 1595 1036  a00FC4B 5C2B                    std     DBGACH       ;(BKP0H) debugger trigger address
 1596 1037  a00FC4D 5C2E                    std     DBGBCH       ;(BKP1H) same for second address to have it initialized
 1597 1038  a00FC4F 45                      rola
 1598 1039  a00FC50 55                      rolb
 1599 1040  a00FC51 45                      rola
 1600 1041  a00FC52 55                      rolb				 ;get ready to search pagebits table
 1601 1042  a00FC53 C403                    andb   #$03          ;what range 0-3FFF,4000-7FFF,8000-BFFF,or C000-FFFF?
 1602 1043  a00FC55 87                      clra
 1603 1044  a00FC56 59                      lsld
 1604 1045  a00FC57 B7C5                    xgdx
 1605 1046  a00FC59 EEE2 FC38               ldx     pagebitsaddr,x
 1606 1047  a00FC5D A600                    ldaa    0,x
 1607 1048                      
 1608 1049  a00FC5F 5A2A                    staa    DBGACX       ;(BKP0X) set page byte of address
 1609 1050  a00FC61 5A2D                    staa    DBGBCX       ;(BKP1X) same for second address to have it initialized
 1610 1051  a00FC63 8680                    ldaa   #traceOne     ; enable, arm, CPU force
 1611 1052  a00FC65 5A28                    staa    DBGC2        ;(BKPCT0) arm DBG to trigger after 1 instr.
 1612 1053  a00FC67 0B                      rti                  ; restore regs and go to user code
 1613 1054                      
 1614 1055                      ;*********************************************************************
 1615 1056                      ;* Go Command - go to user's program at current PC address
 1616 1057                      ;*  8-bit command code from host to SCI0 RxD
 1617 1058                      ;* - no promt is issued 
 1618 1059                      ;*  typically, an SWI will cause control to pass back to the monitor
 1619 1060                      ;*********************************************************************
 1620 1061  a00FC68 4CCB 20     GoCmd:       bset SCI0CR2,RIE     ;need to enable SCI0 Rx interrupts to
 1621 1062                                                        ; enter monitor on any char received
 1622 1063  a00FC6B 4DCA 04                  bclr  flagReg,TraceFlag ; run flag clr
 1623 1064  a00FC6E 0B                       rti                  ;restore regs and exit
 1624 1065                      ;*********************************************************************
 1625 1066                      ;* Utility to send a 16-bit value out X through SCI0
 1626 1067                      ;*********************************************************************
 1627 1068  a00FC6F B7C5        put16:       exg    d,x           ;move IX to A
 1628 1069  a00FC71 0719                     bsr    PutChar       ;send high byte
 1629 1070  a00FC73 180F                     tba                  ;move B to A
 1630 1071  a00FC75 0715                     bsr    PutChar       ;send low byte
 1631 1072  a00FC77 3D                       rts
 1632 1073                      
 1633 1074                      ;*********************************************************************
 1634 1075                      ;* Utility to get a 16-bit value through SCI0 into X
 1635 1076                      ;*********************************************************************
 1636 1077  a00FC78 0709        getX:        bsr    GetChar       ;get high byte

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1637 1078  a00FC7A 180E                     tab                  ;save in B
 1638 1079  a00FC7C 0705                     bsr    GetChar       ;get low byte
 1639 1080  a00FC7E B781                     exg    a,b           ;flip high and low byte
 1640 1081  a00FC80 B7C5                     exg    d,x           ;16-bit value now in IX
 1641 1082  a00FC82 3D                       rts
 1642 1083                      ;*********************************************************************
 1643 1084                      ;* GetChar - wait indefinitely for a character to be received
 1644 1085                      ;*  through SCI0 (until RDRF becomes set) then read char into A
 1645 1086                      ;*  and return. Reading character clears RDRF. No error checking.
 1646 1087                      ;*
 1647 1088                      ;* Calling convention:
 1648 1089                      ;*            bsr    GetChar
 1649 1090                      ;*
 1650 1091                      ;* Returns: received character in A
 1651 1092                      ;*********************************************************************
 1652 1093  a00FC83 4ECC 2002   GetChar:     brset  SCI0SR1,RDRF,RxReady ;exit loop when RDRF=1
 1653 1094  a00FC87 20FA                     bra    GetChar              ;loop till RDRF set
 1654 1095  a00FC89 96CF        RxReady:     ldaa   SCI0DRL              ;read character into A
 1655 1096  a00FC8B 3D                       rts                         ;return
 1656 1097                      
 1657 1098                      ;*********************************************************************
 1658 1099                      ;* PutChar - sends the character in A out SCI0
 1659 1100                      ;*
 1660 1101                      ;* Calling convention:
 1661 1102                      ;*            ldaa    data          ;character to be sent
 1662 1103                      ;*            bsr    PutChar
 1663 1104                      ;*
 1664 1105                      ;* Returns: nothing (A unchanged)
 1665 1106                      ;*********************************************************************
 1666 1107  a00FC8C 4FCC 80FC   PutChar:     brclr   SCI0SR1,TDRE,PutChar ;wait for Tx ready
 1667 1108  a00FC90 5ACF                     staa    SCI0DRL       ;send character from A
 1668 1109  a00FC92 3D                       rts
 1669 1110                      
 1670 1111                      ;*********************************************************************
 1671 1112                      ;* CheckModule - check in what memory type the address in IX points to
 1672 1113                      ;*  The location may be RAM, FLASH, EEPROM, or a register
 1673 1114                      ;*  if the vector table is addresses, IX is changed to point to the
 1674 1115                      ;*  same vector in the pseudo vector table
 1675 1116                      ;*  returns in B: 1 FLASH or EEPROM
 1676 1117                      ;*                0 RAM or register (all the rest of the address space)
 1677 1118                      ;*               -1 access denied (monitor or pseudo vector)
 1678 1119                      ;*  all registers are preserved except B
 1679 1120                      ;*********************************************************************
 1680 1121  a00FC93 3B          CheckModule: pshd                 ;preserve original data
 1681 1122  a00FC94 8E40 00                  cpx    #RomStart
 1682 1123  a00FC97 2514                     blo    check4EE      ;skip if not flash
 1683 1124  a00FC99 8EFF 80                  cpx    #VectorTable
 1684 1125  a00FC9C 2409                     bhs    isVector      ;is it in the real vector table
 1685 1126  a00FC9E 8EF7 80                  cpx    #PVecTable
 1686 1127  a00FCA1 2518                     blo    isToProgram   ;pseudo vector table or monitor area
 1687 1128  a00FCA3 C6FF                     ldab   #$FF          ;access denied (N=1, Z=0)
 1688 1129  a00FCA5 3A                       puld                 ;restore original data (D)
 1689 1130  a00FCA6 3D                       rts
 1690 1131                      
 1691 1132  a00FCA7 1AE2 F800   isVector:    leax   BootStart,x   ;access pseudo vector table
 1692 1133  a00FCAB 200E                     bra    isToProgram
 1693 1134                      
 1694 1135  a00FCAD 4F1C 300E   check4EE:    brclr  MEMSIZ0,eep_sw1+eep_sw0,isRAM  ;Check if device has EEprom
 1695 1136  a00FCB1 8E00 00     			       cpx   #EEpromStart
 1696 1137  a00FCB4 2509                     blo    isRAM         ;treat as RAM or registers
 1697 1138  a00FCB6 8E00 00     			       cpx   #EEpromEnd	  ;Greater than allocated EE space?
 1698 1139  a00FCB9 2204                     bhi    isRAM         ;must be registers or RAM
 1699 1140  a00FCBB C601        isToProgram: ldab   #1            ;set flgs - signal FLASH (N=0, Z=0)
 1700 1141  a00FCBD 3A                       puld                 ;restore original data (D)

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1701 1142  a00FCBE 3D                       rts
 1702 1143                      
 1703 1144  a00FCBF C7          isRAM:       clrb                 ;signal RAM  (N=0, Z=1)
 1704 1145  a00FCC0 3A                       puld                 ;restore original data (D)
 1705 1146  a00FCC1 3D                       rts
 1706 1147                      
 1707 1148                      ;*********************************************************************
 1708 1149                      ;* WriteD2IX - Write the data in D (word) to the address in IX
 1709 1150                      ;*  The location may be RAM, FLASH, EEPROM, or a register
 1710 1151                      ;*  if FLASH or EEPROM, the operation is completed before return
 1711 1152                      ;*  IX and A preserved, returns Z=1 (.EQ.) if OK
 1712 1153                      ;*
 1713 1154                      ;*********************************************************************
 1714 1155  a00FCC2 34          WriteD2IX:   pshx                 ;preserve original address
 1715 1156  a00FCC3 3B                       pshd                 ;preserve original data
 1716 1157  a00FCC4 07CD                     bsr    CheckModule
 1717 1158  a00FCC6 2B50                     bmi    ExitWrite     ;deny access (monitor or pseudo vector)
 1718 1159  a00FCC8 2715                     beq    isRAMword
 1719 1160  a00FCCA AC00                     cpd    0,x           ;FLASH or EEPROM needs programming
 1720 1161  a00FCCC 274A                     beq    ExitWrite     ;exit (OK) if already the right data
 1721 1162  a00FCCE 3B                       pshd                 ;temp save data to program
 1722 1163  a00FCCF B751                     tfr    x,b           ;low byte of target address -> B
 1723 1164  a00FCD1 C501                     bitb   #1            ;is B0 = 1?
 1724 1165  a00FCD3 2605                     bne    oddAdrErr     ;then it's odd addr -> exit
 1725 1166  a00FCD5 EC00                     ldd    0,x           ;$FFFF if it was erased
 1726 1167  a00FCD7 8CFF FF                  cpd    #$FFFF        ;Z=1 if location was erased first
 1727 1168  a00FCDA 3A          oddAdrErr:   puld                 ;recover data, don't change CCR
 1728 1169  a00FCDB 263B                     bne    ExitWrite     ;exit w/ Z=0 to indicate error
 1729 1170  a00FCDD 202C                     bra    DoProgram
 1730 1171                      
 1731 1172  a00FCDF 6C00        isRAMword:   std    0,x           ;write to RAM or register
 1732 1173  a00FCE1 87                       clra                 ;force Z=1 to indicate OK
 1733 1174  a00FCE2 2034                     bra    ExitWrite
 1734 1175                      
 1735 1176                      ;*********************************************************************
 1736 1177                      ;* WriteA2IX - Write the data in A (byte) to the address in IX
 1737 1178                      ;*  The location may be RAM, FLASH, EEPROM, or a register
 1738 1179                      ;*  if FLASH or EEPROM, the operation is completed before return
 1739 1180                      ;*  IX and A preserved, returns Z=1 (.EQ.) if OK
 1740 1181                      ;*
 1741 1182                      ;* Note: Byte writing to the FLASH and EEPROM arrays is a violation
 1742 1183                      ;*       of the HC9S12 specification. Doing so, will reduce long term
 1743 1184                      ;*       data retention and available prog / erase cycles
 1744 1185                      ;*
 1745 1186                      ;*********************************************************************
 1746 1187                      
 1747 1188  a00FCE4 34          WriteA2IX:   pshx                 ;preserve original address
 1748 1189  a00FCE5 3B                       pshd                 ;preserve original data
 1749 1190  a00FCE6 07AB                     bsr    CheckModule
 1750 1191  a00FCE8 2B2E                     bmi    ExitWrite     ;deny access (monitor or pseudo vector)
 1751 1192  a00FCEA 271A                     beq    isWRAMbyte      
 1752 1193  a00FCEC A100                     cmpa   0,x           ;FLASH or EEPROM needs programming 
 1753 1194  a00FCEE 2728                     beq    ExitWrite     ;exit (OK) if already the right data
 1754 1195  a00FCF0 E600                     ldab   0,x           ;$FF if it was erased
 1755 1196  a00FCF2 52                       incb                 ;Z=1 if location was erased first
 1756 1197  a00FCF3 2623                     bne    ExitWrite     ;exit w/ Z=0 to indicate error
 1757 1198                              
 1758 1199  a00FCF5 B751                     tfr    x,b           ;test least significant bit
 1759 1200  a00FCF7 C501                     bitb   #1            ;is B0 = 1?
 1760 1201  a00FCF9 2604                     bne    isOddAdr      ;then it's odd addr.             
 1761 1202  a00FCFB E601        isEvenAdr:   ldab   1,x           ;low byte of D (A:B) from memory
 1762 1203  a00FCFD 200C                     bra    DoProgram                     
 1763 1204  a00FCFF 180E        isOddAdr:    tab                  ;move to low byte of D (A:B)
 1764 1205  a00FD01 09                       dex                  ;point to even byte

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1765 1206  a00FD02 A600                     ldaa   ,x            ;high byte of D (A:B) from memory  
 1766 1207  a00FD04 2005                     bra    DoProgram                        
 1767 1208                                                           
 1768 1209  a00FD06 6A00        isWRAMbyte:  staa   0,x           ;write to RAM or register
 1769 1210  a00FD08 87                       clra                 ;force Z=1 to indicate OK
 1770 1211  a00FD09 200D                     bra    ExitWrite 
 1771 1212                      
 1772 1213                      ; Programs D to IX in either FLASH or EEPROM
 1773 1214  a00FD0B 0727        DoProgram:   bsr    abClr         ;abort commands and clear errors
 1774 1215  a00FD0D 8E40 00                  cpx    #RomStart     ;simple test only
 1775 1216  a00FD10 2504                     blo    itsEE         ; details already verified
 1776 1217  a00FD12 072B                     bsr    ProgFlash     ;program the requested location
 1777 1218  a00FD14 2002                     bra    ExitWrite     ;exit (Z indicates good or bad)
 1778 1219  a00FD16 0703        itsEE:       bsr    ProgEE        ;program the requested location
 1779 1220                      ; exit Write?2IX functions (Z indicates good or bad)
 1780 1221  a00FD18 3A          ExitWrite:   puld                 ;restore original data (D)
 1781 1222  a00FD19 30                       pulx                 ;restore original address (IX)
 1782 1223  a00FD1A 3D                       rts
 1783 1224                      
 1784 1225                      ;*********************************************************************
 1785 1226                      ;* Progee - program a single word in the HCS9S12 EEPROM
 1786 1227                      ;*  the location is assumed to be previously erased. This routine
 1787 1228                      ;*  waits for the command to complete.
 1788 1229                      ;*
 1789 1230                      ;* On entry... IX - points at the EEPROM address to be programmed
 1790 1231                      ;*  A - holds the data value to be programmed
 1791 1232                      ;*
 1792 1233                      ;* Calling convention:
 1793 1234                      ;*           bsr    Prog1ee
 1794 1235                      ;*
 1795 1236                      ;* Returns: IX unchanged and A = ESTAT shifted left by 2 bits
 1796 1237                      ;*  Z=1 if OK, Z=0 if protect violation or access error
 1797 1238                      ;*********************************************************************
 1798 1239  a00FD1B 6C00        ProgEE:      std     ,x           ;latch address & data to program
 1799 1240  a00FD1D 8620                     ldaa    #ProgWord    ;Select program word command
 1800 1241  a00FD1F 7A01 16                  staa    ECMD         ;issue word program command
 1801 1242  a00FD22 8680                     ldaa    #CBEIF
 1802 1243  a00FD24 7A01 15                  staa    ESTAT        ;[pwpp] register command
 1803 1244  a00FD27 A7                       nop                  ;[p]
 1804 1245  a00FD28 A7                       nop
 1805 1246  a00FD29 A7                       nop
 1806 1247  a00FD2A B601 15     ChkDoneEE:   ldaa    ESTAT        ;[prpp] (min 4~ before 1st read)
 1807 1248  a00FD2D 84C0                     anda   #$C0          ; mask all but 2 msb
 1808 1249  a00FD2F 48                       lsla                 ;CCIF now in MSB
 1809 1250  a00FD30 2AF8                     bpl    ChkDoneEE     ;wait for queued commands to finish
 1810 1251  a00FD32 48                       asla                 ;A=00 & Z=1 unless PVIOL or ACCERR
 1811 1252  a00FD33 3D          xProgEE      rts
 1812 1253                      
 1813 1254                      ;
 1814 1255                      ; utility sub to abort previous commands in flash and EEPROM
 1815 1256                      ; and clear any pending errors
 1816 1257                      ;
 1817 1258  a00FD34 36          abClr:       psha
 1818 1259  a00FD35 8630                     ldaa    #PVIOL+ACCERR ;mask
 1819 1260  a00FD37 7A01 15                  staa    ESTAT         ;abort any command and clear errors
 1820 1261  a00FD3A 7A01 05                  staa    FSTAT         ;abort any command and clear errors
 1821 1262  a00FD3D 32                       pula
 1822 1263  a00FD3E 3D                       rts
 1823 1264                      
 1824 1265                      ;*********************************************************************
 1825 1266                      ;* Progflash - programs one word of HCS9S12 FLASH
 1826 1267                      ;*  This routine waits for the command to complete before returning.
 1827 1268                      ;*  assumes location was blank. This routine can be run from FLASH
 1828 1269                      ;*

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1829 1270                      ;* On entry... IX - points at the FLASH byte to be programmed
 1830 1271                      ;*             D holds the data for the location to be programmed
 1831 1272                      ;*
 1832 1273                      ;* Calling convention:
 1833 1274                      ;*           bsr    Prog1flash
 1834 1275                      ;*
 1835 1276                      ;* Uses: DoOnStack which uses SpSub
 1836 1277                      ;* Returns: IX unchanged and A = FSTAT bits PVIOL and ACCERR only
 1837 1278                      ;*  Z=1 if OK, Z=0 if protect violation or access error
 1838 1279                      ;*********************************************************************
 1839 1280  a00FD3F DD30        ProgFlash:   ldy    PPAGE         ;	 Move PPAGE to Stack for storage
 1840 1281  a00FD41 35                       pshy
 1841 1282  a00FD42 3B                       pshd
 1842 1283  a00FD43 8E80 00                  cpx   #$8000         ; if <$8000 then bank $3E
 1843 1284  a00FD46 250C                     blo    its3E         ;set ppage to $3E
 1844 1285  a00FD48 8EC0 00                  cpx   #$C000         ; if > $BFFF then bank $3F
 1845 1286  a00FD4B 250C                     blo    ProgFlash1    ;else use ppage value
 1846 1287  a00FD4D 180B 3F00                movb  #$3F,PPAGE     ;set ppage $3F
             00FD51 30         
 1847 1288  a00FD52 2005                     bra    ProgFlash1
 1848 1289  a00FD54 180B 3E00   its3E:       movb  #$3E,PPAGE     ;set ppage $3E
             00FD58 30         
 1849 1290                      
 1850 1291  a00FD59 D630        ProgFlash1:  ldab   PPAGE
 1851 1292  a00FD5B 272E                     beq    ppagezero
 1852 1293  a00FD5D 54          ProgFlash2:  lsrb                 ; calculate the value of the block select bits based
 1853 1294  a00FD5E 54                       lsrb                 ; on bits 3:2 of the PPAGE register value. (<256k)
 1854 1295  a00FD5F CD04 00                  ldy   #SectorSize    ; get high byte of size
 1855 1296  a00FD62 8D02 00                  cpy   #$0200         ; if larger than $200 shift again
 1856 1297  a00FD65 2701                     beq    nBlockLoopb
 1857 1298  a00FD67 54                       lsrb                 ; on bits 4:3 of the PPAGE register value. (512k)
 1858 1299                      
 1859 1300  a00FD68 51          nBlockLoopb: comb
 1860 1301  a00FD69 C403                     andb  #$03           ; mask off all but the lower 2 bits.
 1861 1302  a00FD6B 7B01 03                  stab   FCNFG         ; select the block to program.
 1862 1303  a00FD6E C100                     cmpb  #$00           ; if block zero use DoOnStack method
 1863 1304  a00FD70 3A                       puld
 1864 1305  a00FD71 271E                     beq    ProgFlashSP
 1865 1306                      
 1866 1307  a00FD73 6C00        ProgFlshRom: std    ,x            ;latch address & data to program
 1867 1308  a00FD75 8620                     ldaa  #ProgWord         ;Select program word command
 1868 1309  a00FD77 7A01 06                  staa   FCMD          ;issue byte program command
 1869 1310  a00FD7A 8680                     ldaa  #CBEIF
 1870 1311  a00FD7C 0742                     bsr    SpSub         ;register command & wait to finish
 1871 1312  a00FD7E B601 05                  ldaa   FSTAT
 1872 1313  a00FD81 8430                     anda  #$30           ;mask all but PVIOL or ACCERR
 1873 1314  a00FD83 B721        		         tfr    ccr,b		      ;get copy of ccr
 1874 1315  a00FD85 31                       puly
 1875 1316  a00FD86 5D30                     sty    PPAGE         ;	 Move PPAGE from Stack
 1876 1317  a00FD88 B712                     tfr	  b,ccr		      ;restore ccr and int condition
 1877 1318  a00FD8A 3D                       rts									; Z=1 if OK, Z=0 if error
 1878 1319                      
 1879 1320  a00FD8B C638        ppagezero:	 ldab		#LowestPage		;PPAGE was zero (reset state)
 1880 1321  a00FD8D 5B30                     stab   PPAGE					; Then set to lowest page.
 1881 1322  a00FD8F 20CC                     bra		ProgFlash2
 1882 1323                      
 1883 1324  a00FD91 6C00        ProgFlashSP: std    ,x            ;latch address and data
 1884 1325  a00FD93 8620                     ldaa  #ProgWord      ;Select program word command
 1885 1326  a00FD95 7A01 06                  staa   FCMD          ;issue byte program command
 1886 1327  a00FD98 16FD A3                  jsr    DoOnStack;
 1887 1328  a00FD9B B721        		         tfr    ccr,b		      ;get copy of ccr
 1888 1329  a00FD9D 31                       puly
 1889 1330  a00FD9E 5D30                     sty    PPAGE         ;	 Move PPAGE from Stack
 1890 1331  a00FDA0 B712                     tfr	  b,ccr		      ;restore ccr and int condition

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1891 1332  a00FDA2 3D                       rts									; Z=1 if OK, Z=0 if error
 1892 1333                                   
 1893 1334                      ; DoOnStack will register the command then wait for it to finish
 1894 1335                      ;  in this unusual case where DoOnStack is the next thing in program
 1895 1336                      ;  memory, we don't need to call it. The rts at the end of DoOnStack
 1896 1337                      ;  will return to the code that called Prog1flash.
 1897 1338                      ;
 1898 1339                      ;*********************************************************************
 1899 1340                      ;* DoOnStack - copy SpSub onto stack and call it (see also SpSub)
 1900 1341                      ;*  De-allocates the stack space used by SpSub after returning from it.
 1901 1342                      ;*  Allows final steps in a flash prog/erase command to execute out
 1902 1343                      ;*  of RAM (on stack) while flash is out of the memory map
 1903 1344                      ;*  This routine can be used for flash word-program or erase commands
 1904 1345                      ;*
 1905 1346                      ;* Calling Convention:
 1906 1347                      ;*           bsr    DoOnStack
 1907 1348                      ;*
 1908 1349                      ;* Uses 22 bytes on stack + 2 bytes if BSR/bsr used to call it
 1909 1350                      ;* returns IX unchanged
 1910 1351                      ;********************************************************************
 1911 1352  a00FDA3 34          DoOnStack:   pshx                 ;save IX
 1912 1353  a00FDA4 CEFD D0                  ldx   #SpSubEnd-2    ;point at last word to move to stack
 1913 1354  a00FDA7 EC3E        SpmoveLoop:  ldd    2,x-          ;read from flash
 1914 1355  a00FDA9 3B                       pshd                 ;move onto stack
 1915 1356  a00FDAA 8EFD BE                  cpx   #SpSub-2       ;past end?
 1916 1357  a00FDAD 26F8                     bne    SpmoveLoop    ;loop till whole sub on stack
 1917 1358  a00FDAF B775                     tfr    sp,x          ;point to sub on stack
 1918 1359  a00FDB1 8680                     ldaa  #CBEIF         ;preload mask to register command
 1919 1360  a00FDB3 1500                     jsr    ,x            ;execute the sub on the stack
 1920 1361  a00FDB5 1BF2 0012                leas   SpSubEnd-SpSub,sp  ;de-allocate space used by sub
 1921 1362  a00FDB9 B601 05                  ldaa   FSTAT         ;get result of operation
 1922 1363  a00FDBC 8430                     anda  #$30           ;and mask all but PVIOL or ACCERR
 1923 1364  a00FDBE 30                       pulx                 ;restore IX
 1924 1365  a00FDBF 3D                       rts                  ;to flash where DoOnStack was called
 1925 1366                      
 1926 1367                      ;*********************************************************************
 1927 1368                      ;* SpSub - register flash command and wait for Flash CCIF
 1928 1369                      ;*  this subroutine is copied onto the stack before executing
 1929 1370                      ;*  because you can't execute out of flash while a flash command is
 1930 1371                      ;*  in progress (see DoOnStack to see how this is used)
 1931 1372                      ;*
 1932 1373                      ;* Uses 18 bytes on stack + 2 bytes if a BSR/bsr calls it
 1933 1374                      ;*********************************************************************
 1934 1375                                   EVEN   			  ;Make code start word aliened
 1935 1376                      SpSub:       
 1936 1377  a00FDC0 B721        		         tfr    ccr,b		  ;get copy of ccr
 1937 1378  a00FDC2 1410        			       orcc  #$10			  ;disable interrupts
 1938 1379  a00FDC4 7A01 05                  staa   FSTAT         ;[PwO] register command
 1939 1380  a00FDC7 A7                       nop                  ;[O] wait min 4~ from w cycle to r
 1940 1381  a00FDC8 A7                       nop                  ;[O]
 1941 1382  a00FDC9 A7                       nop                  ;[O]
 1942 1383  a00FDCA 1F01 0540                brclr  FSTAT,CCIF,*  ;[rfPPP] wait for queued commands to finish
             00FDCE FB         
 1943 1384  a00FDCF B712                     tfr	b,ccr		    ;restore ccr and int condition
 1944 1385  a00FDD1 3D                       rts                  ;back into DoOnStack in flash
 1945 1386                      SpSubEnd:
 1946 1387                      ;*********************************************************************
 1947 1388                      ;* User Pseudo-vector Equates (just before protected block)
 1948 1389                      ;*  real vectors point here, each pseudo-vector is a bra instruction
 1949 1390                      ;*  to the user's ISR.
 1950 1391                      ;*********************************************************************
 1951 1392                      BSRTable:
 1952 1393  a00FDD2 077E        uvector63:	bsr    ISRHandler    ; /* vector 63 */
 1953 1394  a00FDD4 077C        uvector62:	bsr    ISRHandler    ; /* vector 62 */

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1954 1395  a00FDD6 077A        uvector61:	bsr    ISRHandler    ; /* vector 61 */
 1955 1396  a00FDD8 0778        uvector60:	bsr    ISRHandler    ; /* vector 60 */
 1956 1397  a00FDDA 0776        uvector59:	bsr    ISRHandler    ; /* vector 59 */
 1957 1398  a00FDDC 0774        uvector58:	bsr    ISRHandler    ; /* vector 58 */
 1958 1399  a00FDDE 0772        uvector57:	bsr    ISRHandler    ; /* vector 57 */
 1959 1400  a00FDE0 0770        uvector56:	bsr    ISRHandler    ; /* vector 56 */
 1960 1401  a00FDE2 076E        uvector55:	bsr    ISRHandler    ; /* vector 55 */
 1961 1402  a00FDE4 076C        uvector54:	bsr    ISRHandler    ; /* vector 54 */
 1962 1403  a00FDE6 076A        uvector53:	bsr    ISRHandler    ; /* vector 53 */
 1963 1404  a00FDE8 0768        uvector52:	bsr    ISRHandler    ; /* vector 52 */
 1964 1405  a00FDEA 0766        uvector51:	bsr    ISRHandler    ; /* vector 51 */
 1965 1406  a00FDEC 0764        uvector50:	bsr    ISRHandler    ; /* vector 50 */
 1966 1407  a00FDEE 0762        uvector49:	bsr    ISRHandler    ; /* vector 49 */
 1967 1408  a00FDF0 0760        uvector48:	bsr    ISRHandler    ; /* vector 48 */
 1968 1409  a00FDF2 075E        uvector47:	bsr    ISRHandler    ; /* vector 47 */
 1969 1410  a00FDF4 075C        uvector46:	bsr    ISRHandler    ; /* vector 46 */
 1970 1411  a00FDF6 075A        uvector45:	bsr    ISRHandler    ; /* vector 45 */
 1971 1412  a00FDF8 0758        uvector44:	bsr    ISRHandler    ; /* vector 44 */
 1972 1413  a00FDFA 0756        uvector43:	bsr    ISRHandler    ; /* vector 43 */
 1973 1414  a00FDFC 0754        uvector42:	bsr    ISRHandler    ; /* vector 42 */
 1974 1415  a00FDFE 0752        uvector41:	bsr    ISRHandler    ; /* vector 41 */
 1975 1416  a00FE00 0750        uvector40:	bsr    ISRHandler    ; /* vector 40 */
 1976 1417  a00FE02 074E        uvector39:	bsr    ISRHandler    ; /* vector 39 */
 1977 1418  a00FE04 074C        uvector38:	bsr    ISRHandler    ; /* vector 38 */
 1978 1419  a00FE06 074A        uvector37:	bsr    ISRHandler    ; /* vector 37 */
 1979 1420  a00FE08 0748        uvector36:	bsr    ISRHandler    ; /* vector 36 */
 1980 1421  a00FE0A 0746        uvector35:	bsr    ISRHandler    ; /* vector 35 */
 1981 1422  a00FE0C 0744        uvector34:	bsr    ISRHandler    ; /* vector 34 */
 1982 1423  a00FE0E 0742        uvector33:	bsr    ISRHandler    ; /* vector 33 */
 1983 1424  a00FE10 0740        uvector32:	bsr    ISRHandler    ; /* vector 32 */
 1984 1425  a00FE12 073E        uvector31:	bsr    ISRHandler    ; /* vector 31 */
 1985 1426  a00FE14 073C        uvector30:	bsr    ISRHandler    ; /* vector 30 */
 1986 1427  a00FE16 073A        uvector29:	bsr    ISRHandler    ; /* vector 29 */
 1987 1428  a00FE18 0738        uvector28:	bsr    ISRHandler    ; /* vector 28 */
 1988 1429  a00FE1A 0736        uvector27:	bsr    ISRHandler    ; /* vector 27 */
 1989 1430  a00FE1C 0734        uvector26:	bsr    ISRHandler    ; /* vector 26 */
 1990 1431  a00FE1E 0732        uvector25:	bsr    ISRHandler    ; /* vector 25 */
 1991 1432  a00FE20 0730        uvector24:	bsr    ISRHandler    ; /* vector 24 */
 1992 1433  a00FE22 072E        uvector23:	bsr    ISRHandler    ; /* vector 23 */
 1993 1434  a00FE24 072C        uvector22:	bsr    ISRHandler    ; /* vector 22 */
 1994 1435  a00FE26 072A        uvector21:	bsr    ISRHandler    ; /* vector 21 */
 1995 1436  a00FE28 0728        uvector20:	bsr    ISRHandler    ; SCI0, used for monitor (place holder only)
 1996 1437  a00FE2A 0726        uvector19:	bsr    ISRHandler    ; /* vector 19 */
 1997 1438  a00FE2C 0724        uvector18:	bsr    ISRHandler    ; /* vector 18 */
 1998 1439  a00FE2E 0722        uvector17:	bsr    ISRHandler    ; /* vector 17 */
 1999 1440  a00FE30 0720        uvector16:	bsr    ISRHandler    ; /* vector 16 */
 2000 1441  a00FE32 071E        uvector15:	bsr    ISRHandler    ; /* vector 15 */
 2001 1442  a00FE34 071C        uvector14:	bsr    ISRHandler    ; /* vector 14 */
 2002 1443  a00FE36 071A        uvector13:	bsr    ISRHandler    ; /* vector 13 */
 2003 1444  a00FE38 0718        uvector12:	bsr    ISRHandler    ; /* vector 12 */
 2004 1445  a00FE3A 0716        uvector11:	bsr    ISRHandler    ; /* vector 11 */
 2005 1446  a00FE3C 0714        uvector10:	bsr    ISRHandler    ; /* vector 10 */
 2006 1447  a00FE3E 0712        uvector09:	bsr    ISRHandler    ; /* vector 09 */
 2007 1448  a00FE40 0710        uvector08:	bsr    ISRHandler    ; /* vector 08 */
 2008 1449  a00FE42 070E        uvector07:	bsr    ISRHandler    ; /* vector 07 */
 2009 1450  a00FE44 070C        uvector06:	bsr    ISRHandler    ; /* vector 06 */
 2010 1451  a00FE46 070A        uvector05:	bsr    ISRHandler    ; /* vector 05 */
 2011 1452  a00FE48 0708        			bsr    ISRHandler    ; SWI, used for breakpoints (place holder only)
 2012 1453  a00FE4A 0706        uvector03:	bsr    ISRHandler    ; /* vector 03 */
 2013 1454  a00FE4C 0704        uvector02:	bsr    ISRHandler    ; /* vector 02 */
 2014 1455  a00FE4E 0702        uvector01:	bsr    ISRHandler    ; /* vector 01 */
 2015 1456  a00FE50 0700                    bsr    ISRHandler    ; /* Reset vector */
 2016 1457                      
 2017 1458                      ;*********************************************************************

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 2018 1459                      ;* ISRHandler this routine checks for unprogrammed interrupt
 2019 1460                      ;*  vectors and returns an $E3 error code if execution of an
 2020 1461                      ;*  unprogrammed vector is attempted
 2021 1462                      ;*********************************************************************
 2022 1463  a00FE52 30          ISRHandler:  pulx    ;pull bsr return address off stack
 2023 1464  a00FE53 EDE2 F9AC                ldy     (PVecTable-BSRTable-2),X
 2024 1465  a00FE57 8DFF FF                  cpy     #$FFFF
 2025 1466  a00FE5A 2702                     beq     BadVector
 2026 1467  a00FE5C 0540                     jmp     ,Y
 2027 1468                      
 2028 1469                      ;*********************************************************************
 2029 1470                      ;* Invalid (erased) vector fetched
 2030 1471                      ;*   low byte of vector address is Status (passed in B to ReenterMon)
 2031 1472                      ;* Leave stack frame from ISR on stack to refresh monitor registers.
 2032 1473                      ;*********************************************************************
 2033 1474                      
 2034 1475  a00FE5E 1AE2 F9AC   BadVector:   leax   (PVecTable-BSRTable-2),X
 2035 1476  a00FE62 B7C5                     xgdx                 ;low byte of vector address in B
 2036 1477  a00FE64 06F9 9C                  jmp    ReenterMon    ;and enter monitor
 2037 1478                      EndMonitor:
 2038 1479                      
 2039 1480          0000 0000     IF EndMonitor >= FProtStart
 2041 1482                        ENDIF
 2042 1483                      ;*********************************************************************
 2043 1484                      ;* Jump table for external use of routines.
 2044 1485                      ;*********************************************************************
 2045 1486                                   org    FProtStart-26 ;immediately before the vector table
 2046 1487  a00FEE6 06FC 8C                  jmp    PutChar
 2047 1488  a00FEE9 06FC 83                  jmp    GetChar
 2048 1489  a00FEEC 06F9 F3                  jmp    EraseAllCmd
 2049 1490  a00FEEF 06FD A3                  jmp    DoOnStack
 2050 1491  a00FEF2 06FC C2                  jmp    WriteD2IX
 2051 1492                      
 2052 1493                                   org    FProtStart-8
 2053 1494  a00FEF8 3000                     fdb    softwareID4	;Software device type (deviceID)
 2054 1495  a00FEFA 0723                     fdb    softwareID1	;Software revision (date)
 2055 1496  a00FEFC 2004                     fdb    softwareID2	;Software revision (year)
 2056 1497  a00FEFE 0202                     fdb    softwareID3	;Software revision (ver)
 2057 1498                      ;
 2058 1499                      ;*********************************************************************
 2059 1500                      ;* FLASH configuration: protection, security
 2060 1501                      ;*********************************************************************
 2061 1502                                   org    FProtStart   ; enable protection
 2062 1503  a00FF00 FFFF                     fdb    $FFFF        ; Skip Backdoor Key
 2063 1504  a00FF02 FFFF                     fdb    $FFFF        ; Skip Backdoor Key
 2064 1505  a00FF04 FFFF                     fdb    $FFFF        ; Skip Backdoor Key
 2065 1506  a00FF06 FFFF                     fdb    $FFFF        ; Skip Backdoor Key
 2066 1507                      
 2067 1508  a00FF08 FFFF                     fdb    $FFFF        ; Skip Reserved
 2068 1509                      
 2069 1510  a00FF0A FF                       fcb    $FF          ; protection block 3
 2070 1511  a00FF0B FF                       fcb    $FF          ; protection block 2
 2071 1512  a00FF0C FF                       fcb    $FF          ; protection block 1
 2072 1513  a00FF0D C7                       fcb    FProtBlksz   ; protection block 0
 2073 1514  a00FF0E FF                       fcb    $FF          ; Skip
 2074 1515  a00FF0F BE                       fcb    FSecure      ; set security and backdoor access
 2075 1516                      ;*********************************************************************
 2076 1517                      ;* Define all vectors even if program doesn't use them all
 2077 1518                      ;*********************************************************************
 2078 1519                      
 2079 1520                                 org    VectorTable
 2080 1521  a00FF80 FDD2        vector63:  fdb    uvector63  ; /* vector 63 */
 2081 1522  a00FF82 FDD4        vector62:  fdb    uvector62  ; /* vector 62 */
 2082 1523  a00FF84 FDD6        vector61:  fdb    uvector61  ; /* vector 61 */

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 2083 1524  a00FF86 FDD8        vector60:  fdb    uvector60  ; /* vector 60 */
 2084 1525  a00FF88 FDDA        vector59:  fdb    uvector59  ; /* vector 59 */
 2085 1526  a00FF8A FDDC        vector58:  fdb    uvector58  ; /* vector 58 */
 2086 1527  a00FF8C FDDE        vector57:  fdb    uvector57  ; /* vector 57 */
 2087 1528  a00FF8E FDE0        vector56:  fdb    uvector56  ; /* vector 56 */
 2088 1529  a00FF90 FDE2        vector55:  fdb    uvector55  ; /* vector 55 */
 2089 1530  a00FF92 FDE4        vector54:  fdb    uvector54  ; /* vector 54 */
 2090 1531  a00FF94 FDE6        vector53:  fdb    uvector53  ; /* vector 53 */
 2091 1532  a00FF96 FDE8        vector52:  fdb    uvector52  ; /* vector 52 */
 2092 1533  a00FF98 FDEA        vector51:  fdb    uvector51  ; /* vector 51 */
 2093 1534  a00FF9A FDEC        vector50:  fdb    uvector50  ; /* vector 50 */
 2094 1535  a00FF9C FDEE        vector49:  fdb    uvector49  ; /* vector 49 */
 2095 1536  a00FF9E FDF0        vector48:  fdb    uvector48  ; /* vector 48 */
 2096 1537  a00FFA0 FDF2        vector47:  fdb    uvector47  ; /* vector 47 */
 2097 1538  a00FFA2 FDF4        vector46:  fdb    uvector46  ; /* vector 46 */
 2098 1539  a00FFA4 FDF6        vector45:  fdb    uvector45  ; /* vector 45 */
 2099 1540  a00FFA6 FDF8        vector44:  fdb    uvector44  ; /* vector 44 */
 2100 1541  a00FFA8 FDFA        vector43:  fdb    uvector43  ; /* vector 43 */
 2101 1542  a00FFAA FDFC        vector42:  fdb    uvector42  ; /* vector 42 */
 2102 1543  a00FFAC FDFE        vector41:  fdb    uvector41  ; /* vector 41 */
 2103 1544  a00FFAE FE00        vector40:  fdb    uvector40  ; /* vector 40 */
 2104 1545  a00FFB0 FE02        vector39:  fdb    uvector39  ; /* vector 39 */
 2105 1546  a00FFB2 FE04        vector38:  fdb    uvector38  ; /* vector 38 */
 2106 1547  a00FFB4 FE06        vector37:  fdb    uvector37  ; /* vector 37 */
 2107 1548  a00FFB6 FE08        vector36:  fdb    uvector36  ; /* vector 36 */
 2108 1549  a00FFB8 FE0A        vector35:  fdb    uvector35  ; /* vector 35 */
 2109 1550  a00FFBA FE0C        vector34:  fdb    uvector34  ; /* vector 34 */
 2110 1551  a00FFBC FE0E        vector33:  fdb    uvector33  ; /* vector 33 */
 2111 1552  a00FFBE FE10        vector32:  fdb    uvector32  ; /* vector 32 */
 2112 1553  a00FFC0 FE12        vector31:  fdb    uvector31  ; /* vector 31 */
 2113 1554  a00FFC2 FE14        vector30:  fdb    uvector30  ; /* vector 30 */
 2114 1555  a00FFC4 FE16        vector29:  fdb    uvector29  ; /* vector 29 */
 2115 1556  a00FFC6 FE18        vector28:  fdb    uvector28  ; /* vector 28 */
 2116 1557  a00FFC8 FE1A        vector27:  fdb    uvector27  ; /* vector 27 */
 2117 1558  a00FFCA FE1C        vector26:  fdb    uvector26  ; /* vector 26 */
 2118 1559  a00FFCC FE1E        vector25:  fdb    uvector25  ; /* vector 25 */
 2119 1560  a00FFCE FE20        vector24:  fdb    uvector24  ; /* vector 24 */
 2120 1561  a00FFD0 FE22        vector23:  fdb    uvector23  ; /* vector 23 */
 2121 1562  a00FFD2 FE24        vector22:  fdb    uvector22  ; /* vector 22 */
 2122 1563  a00FFD4 FE26        vector21:  fdb    uvector21  ; /* vector 21 */
 2123 1564  a00FFD6 F953        vector20:  fdb    SciIsr     ; /* vector 20 */
 2124 1565  a00FFD8 FE2A        vector19:  fdb    uvector19  ; /* vector 19 */
 2125 1566  a00FFDA FE2C        vector18:  fdb    uvector18  ; /* vector 18 */
 2126 1567  a00FFDC FE2E        vector17:  fdb    uvector17  ; /* vector 17 */
 2127 1568  a00FFDE FE30        vector16:  fdb    uvector16  ; /* vector 16 */
 2128 1569  a00FFE0 FE32        vector15:  fdb    uvector15  ; /* vector 15 */
 2129 1570  a00FFE2 FE34        vector14:  fdb    uvector14  ; /* vector 14 */
 2130 1571  a00FFE4 FE36        vector13:  fdb    uvector13  ; /* vector 13 */
 2131 1572  a00FFE6 FE38        vector12:  fdb    uvector12  ; /* vector 12 */
 2132 1573  a00FFE8 FE3A        vector11:  fdb    uvector11  ; /* vector 11 */
 2133 1574  a00FFEA FE3C        vector10:  fdb    uvector10  ; /* vector 10 */
 2134 1575  a00FFEC FE3E        vector09:  fdb    uvector09  ; /* vector 09 */
 2135 1576  a00FFEE FE40        vector08:  fdb    uvector08  ; /* vector 08 */
 2136 1577  a00FFF0 FE42        vector07:  fdb    uvector07  ; /* vector 07 */
 2137 1578  a00FFF2 FE44        vector06:  fdb    uvector06  ; /* vector 06 */
 2138 1579  a00FFF4 FE46        vector05:  fdb    uvector05  ; /* vector 05 */
 2139 1580  a00FFF6 F991        vector04:  fdb    Breakpoint ; /* vector 04 */
 2140 1581  a00FFF8 FE4A        vector03:  fdb    uvector03  ; /* vector 03 */
 2141 1582  a00FFFA F800        vector02:  fdb    ColdStart  ; /* vector 02 */
 2142 1583  a00FFFC FE4E        vector01:  fdb    uvector01  ; /* vector 01 */
 2143 1584  a00FFFE F800        vector00:  fdb    ColdStart  ; /* Reset vector */
 2144 1585                      
 2145 1586                      .nolist                      ;skip the symbol table
 2146 1587                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 2147 1588                      ;*****************************************************************
 2148 1589                      
